* Controlling the Display

#+begin_src emacs-lisp
;;* 14 Controlling the (info "(emacs)Display")

(leuven--chapter leuven-load-chapter-14-display "14 Controlling the Display"
#+end_src

** Scrolling

#+begin_src emacs-lisp
;;** 14.1 (info "(emacs)Scrolling")

  (leuven--section "14.1 (emacs)Scrolling")

  ;; When scrolling, point preserves the cursor position in the buffer if the
  ;; original position is still visible.
  (setq scroll-preserve-screen-position t)
#+end_src

#+begin_src emacs-lisp
    ;; Better scrolling in Emacs (doing a <PageDown> followed by a <PageUp> will
    ;; place the point at the same place).
    (use-package pager
      :config
      (global-set-key (kbd "<prior>") #'pager-page-up)
      (global-set-key (kbd "<next>")  #'pager-page-down)
   )
#+end_src

** Automatic Scrolling

"Smooth" (civilized) scrolling.

#+begin_src emacs-lisp
;;** 14.3 (info "(emacs)Auto Scrolling")

  (leuven--section "14.3 (emacs)Auto Scrolling")

  ;; Scroll only one line at a time (redisplay will never recenter point).
  (setq scroll-conservatively 10000)    ; Or `most-positive-fixnum'.

  ;; Number of lines of margin at the top and bottom of a window.
  (setq scroll-margin 4)                ; Also for `isearch-forward'.

  ;; Scrolling down looks much better.
  (setq auto-window-vscroll nil)
#+end_src

** Horizontal Scrolling

How to automatically add/remove horizontal scrollbars as needed by text width?

** Narrowing

- ~C-x n n~ ::
     *Narrow* down to between point and mark.

- ~C-x n d~ ::
     *Narrow* down to the current *defun*.

- ~C-x n s~ ::
     *Narrow* buffer to the current *subtree* (bound in Org mode).

- ~C-x n w~ ::
     *Widen* to make the entire buffer accessible again.

#+begin_src emacs-lisp
;;** 14.5 (info "(emacs)Narrowing")

  (leuven--section "14.5 (emacs)Narrowing")

  ;; Enable the use of the command `narrow-to-region' without confirmation.
  (put 'narrow-to-region 'disabled nil)

  ;; (with-eval-after-load "fancy-narrow-autoloads"
  ;;   (fancy-narrow-mode)) ; perf problems when calling `helm-for-files' from a big file?
#+end_src

** Font Lock mode

#+begin_src emacs-lisp
;;** 14.12 (info "(emacs)Font Lock")

  (leuven--section "14.12 (emacs)Font Lock")
#+end_src

Prior to running their own mode hooks,
- all text-based major modes run ~text-mode-hook~, and
- all programming language modes run ~prog-mode-hook~.

Add font locking for the following patterns in upper case:

- ~TODO~,
- ~FIXME~,
- ~XXX~ and
- ~BUG~

to all modes except Diff mode and Org mode.

#+begin_note
In Eclipse, they are all *case in-sensitive* by default.
In IntelliJ IDEA, the are recognized in both lower and upper case.
#+end_note

#+begin_example
// TODO(fni) Please make sure that everything works
// FIXME[fni] Main method
// XXX-fni: Add comments
// BUG Review script body

/* TODO this is the normal way */
/* todo this is another to-do */
/*! \todo this is a doxygen to-do */
// TODO this is a C++ to-do comment
#+end_example

#+begin_src emacs-lisp
  (defface leuven-todo-patterns-face
    '((t :weight bold :box "#FF3125" :foreground "#FF3125" :background "#FFFF88"))
    "Face for making TODO items stand out.")

  ;; Highlight tasks.
  (defvar leuven-todo-patterns-in-org
    "\\<\\(\\(FIXME\\|XXX\\|BUG\\)\\(([^)]*)\\)?:?.*\\)" ; Start of word.
    "TODO patterns to highlight (for Org mode only).
  The goal is to ensure no conflict with the Org mode TODO keyword.")

  (defvar leuven-todo-patterns-anywhere
    "\\<\\(\\(TODO\\|FIXME\\|XXX\\|BUG\\)\\(([^)]*)\\)?:?.*\\)"
    "TODO patterns to highlight (for all modes).")

  ;; Add highlighting keywords.
  (defun leuven--highlight-todo-patterns ()
    "Highlight TODO patterns."
    (let ((keywords (cond
                     ((derived-mode-p 'org-mode)
                      `((,leuven-todo-patterns-in-org 1 'leuven-todo-patterns-face prepend)))
                     ((not (derived-mode-p 'diff-mode))
                      `((,leuven-todo-patterns-anywhere 1 'leuven-todo-patterns-face prepend))))))

      (font-lock-add-keywords nil keywords 'end)))

  (add-hook 'find-file-hook #'leuven--highlight-todo-patterns)
#+end_src

See doc of ~font-lock-keywords~ and ~font-lock-add-keywords~.

Check out ~log4j-mode~ instead?  And nice colors at
https://www.jetbrains.com/resharper/help/Regular_Expressions_Assistance.html.

#+begin_src emacs-lisp
  (defun leuven-occur-todo ()
    "Display all lines in the current buffer containing TODO, FIXME, XXX, or BUG."
    (interactive)
    (occur "TODO\\|FIXME\\|XXX\\|BUG"))

  (global-set-key (kbd "<M-f6>") #'leuven-occur-todo)
#+end_src

#+begin_src emacs-lisp
  ;; Just-in-time fontification.
  (use-package jit-lock
    :load-path "site-lisp"
    :config
    ;; Stealth fontification should show status messages.
    (setq jit-lock-stealth-verbose t)
    ;; ;; Idle time after which deferred fontification should take place.
    ;; (setq jit-lock-defer-time 0.05)     ; Improve the scrolling speed in large
    ;;                                     ; files.
  )
#+end_src

** Interactive Highlighting

#+begin_src emacs-lisp
;;** 14.13 (info "(emacs)Highlight Interactively") by Matching

  (leuven--section "14.13 (emacs)Highlight Interactively by Matching")
#+end_src

#+begin_src emacs-lisp
	  ;; Highlight-Changes mode.
	  (use-package "hilit-chg"
	    :load-path "site-lisp"
	    :config
	    (defvar highlight-fringe-mark 'filled-rectangle
	      "The fringe bitmap name marked at changed line.
	       Should be selected from `fringe-bitmaps'."
	    )

	    (defun hilit-chg-make-ov--add-fringe ()
	      (mapc #'(lambda (ov)
			(if (overlay-get ov 'hilit-chg)
			    (let ((fringe-anchor (make-string 1 ?x)))
			      (put-text-property 0 1 'display
						 (list 'left-fringe highlight-fringe-mark)
						 fringe-anchor)
			      (overlay-put ov 'before-string fringe-anchor))))
		    (overlays-at (ad-get-arg 1)))
	    )
	    (advice-add 'hilit-chg-make-ov :after #'hilit-chg-make-ov--add-fringe)
	)

	  ;; ;; Enable Global-Highlight-Changes mode.
	  ;; (global-highlight-changes-mode 1)

	  ;; ;; Changes are initially NOT visible in Highlight Changes mode.
	  ;; (setq highlight-changes-visibility-initial-state nil)
#+end_src

You can use *Hi Lock* (part of Emacs) to highlight a regexp (identical tokens)
throughout a buffer.

- ~M-x hi-lock-mode RET~ ::
     Enable or disable Hi Lock mode.

- ~M-s h .~ ::
      *Highlight* each instance of the *symbol at point*.

- ~M-s h r REGEXP RET~ (~highlight-regexp~) ::
     Highlight text that *matches REGEXP*.

- ~M-s h l REGEXP RET~ ::
     Highlight *entire lines* containing a match for REGEXP.

- ~M-s h p~ (~highlight-phrase~) ::
     When called interactively, replace whitespace in user-provided
     regexp with arbitrary whitespace, and make initial lower-case
     letters case-insensitive, before highlighting with ~hi-lock-set-pattern~.

     ~highlight-phrase~ is just a bit of sugar around ~highlight-regexp~ that

     ignores case and translates a space in the regex to match arbitrary
     whitespace. Handy.

     Also, ~highlight-phrase~ is not fully case insensitive. Only initial
     lower-case letters (of words) ae made case insensitive. (I suppose it was
     intended to deal with fred vs Fred) .. eg it generates a regex like:
     ~[Cc]at[ ]+[Dd]og~

- ~M-s h u REGEXP RET~ ::
     *Unhighlight* REGEXP.

#+begin_src emacs-lisp
  ;; Do not prompt for the face to use. Instead, cycle through them.
  (setq hi-lock-auto-select-face t)

  ;; ;; Enable Hi Lock mode for all buffers.
  ;; (global-hi-lock-mode 1)
#+end_src

It is complementary to the features of the library *Hl-anything*.

- Hi Lock uses *text properties*.  Copying and pasting text will also paste the
  highlighting.

- Hl-anything uses *overlays*.  It prevents highlighted things to be hidden by
  hl-line mode.

  #+begin_note
  As *overlay highlighting* (used by ~hl-line~) *always takes priority over
  text-property highlighting*, the highlighting of symbols should use overlays at
  all times, and thus have higher priority over ~hl-line~ (because shorter
  overlays have an implicitly higher priority, given the same value of
  priority).

  *Use highlighting that is produced by an overlay!*

  + Highlight from Drew Adams
  + highlight-symbol from Nicolas
  + Symbol-overlay from Wolray
  #+end_note

- Hi Lock and Hl-anything both *highlight new text* as you type it.

- Hl-anything lets you *navigate among highlights*: ~hl-find-next-thing~,
  ~hl-find-prev-thing~.

- ~Hl-anything~ automatically chooses *rainbow colors* and makes it much easier to
  follow some key variables through a block of code.

#+begin_note
We tend to think of highlighting a buffer region with a background as putting
such a background behind or underneath the text.  Think of a marker pen
(highlighter) instead: the highlighting goes on top.
#+end_note

#+begin_src emacs-lisp
  ;; ;; Highlight symbols, selections, enclosing parens and more.
  ;; (with-eval-after-load "hl-anything-autoloads"
  ;;
  ;;   (setq hl-highlight-background-colors '("#C7FF85" "#FFFA85" "#85FFFA" "#FCACFF"))
  ;;   ;; See the very good hl-paren-mode.
  ;;
  ;;   ;; Don't save and restore highlight.
  ;;   (setq hl-highlight-save-file nil)
  ;;
  ;;   ;; Emulation of Vim's `*' search.
  ;;   (global-set-key (kbd "C-*")      #'hl-highlight-thingatpt-global)
  ;;   (global-set-key (kbd "C-<f4>")   #'hl-find-next-thing)
  ;;   (global-set-key (kbd "S-<f4>")   #'hl-find-prev-thing)
  ;;   (global-set-key (kbd "C-M-*")    #'hl-unhighlight-all-global))
  ;;
  ;;   ;; ;; Find Next / Move to Next Occurrence.
  ;;   ;; (global-set-key (kbd "<f3>")     #'hl-find-next-thing)
  ;;   ;;
  ;;   ;; ;; Find Previous / Move to Previous Occurrence.
  ;;   ;; (global-set-key (kbd "<S-f3>")   #'hl-find-prev-thing)
  ;;   ;;
  ;;   ;; ;; Find Word at Caret.
  ;;   ;; (global-set-key (kbd "<C-f3>")   #'hl-highlight-thingatpt-global)
  ;;   ;;
  ;;   ;; ;; Highlight Usages in File.
  ;;   ;; (global-set-key (kbd "<C-S-f7>") #'hl-highlight-thingatpt-global)


  (use-package symbol-overlay
    :config
    (global-set-key (kbd "<C-S-f7>") 'symbol-overlay-put)
    (global-set-key (kbd "<f3>") 'symbol-overlay-switch-forward)
    (global-set-key (kbd "<S-f3>") 'symbol-overlay-switch-backward)
    ;; (global-set-key (kbd "<f7>") 'symbol-overlay-mode)
    ;; (global-set-key (kbd "<f8>") 'symbol-overlay-remove-all)
  )
#+end_src

Use Auto-Highlight-Symbol to *automatically highlight* all found *usages of* the
*symbol at point* in the current file (if you pause on a symbol).  When you move
point, the highlighting goes away.

#+begin_tip
~ahs~ can find the *definition* of a symbol, and colors it differently!
#+end_tip

#+begin_src emacs-lisp
  ;; Automatic highlighting occurrences of the current symbol under cursor.
  (use-package auto-highlight-symbol
    :config
      ;; Add major modes Auto-Highlight-Symbol can run on.
      (mapc #'(lambda (mode)
                (add-to-list 'ahs-modes mode t))
            '(js2-mode
              ess-mode))                  ; R.
      ;; Number of seconds to wait before highlighting the current symbol.
      (setq ahs-idle-interval 0.2) ; 0.35.

      ;; Unset AHS key bindings that override Org key bindings.
      (define-key auto-highlight-symbol-mode-map (kbd "<M-left>")    nil)
      (define-key auto-highlight-symbol-mode-map (kbd "<M-right>")   nil)
      (define-key auto-highlight-symbol-mode-map (kbd "<M-S-left>")  nil)
      (define-key auto-highlight-symbol-mode-map (kbd "<M-S-right>") nil)

      ;; ;; Toggle Auto-Highlight-Symbol mode in all buffers.
      ;; (global-auto-highlight-symbol-mode t)

      ;; Enable Auto-Highlight-Symbol mode in all programming mode buffers.
      (add-hook 'prog-mode-hook #'auto-highlight-symbol-mode)

      ;; Enable Auto-Highlight-Symbol mode in LaTeX mode.
      (add-hook 'latex-mode-hook #'auto-highlight-symbol-mode)
  )
#+end_src

XXX Check out ~light-symbol~.

Color Identifiers Mode: *color* every *variable* in its own, consistent color.

#+begin_src emacs-lisp
;; XXX Impact on Org's HTML export?
  ;; (with-eval-after-load "color-identifiers-mode-autoloads"
  ;;
  ;;   (add-hook 'after-init-hook #'global-color-identifiers-mode))
#+end_src

** Window Fringes

Show an icon in the fringe of version-controlled files indicating which *lines*
have been *edited* (inserted, modified or deleted) *since the last commit*.  Similar
to Git Gutter.

This feature gives you a really nice at-a-glance view of where you've made
changes.

#+begin_tip
If you need to know what lines changed in latest commit as well, you can enable
~diff-hl-amend-mode~ to *show changes against the second-last revision*.
#+end_tip

#+begin_src emacs-lisp
  (use-package diff-hl
    :config
  ;; Indicate changes in the fringe.
    (global-diff-hl-mode 1)
  
#+end_src

If you're using some package other than ~vc~ to commit changes, it might not run
~vc-checkin-hook~ after commits.  In that case, you'll need to either add
~diff-hl-update~ to the hook it does run, or advise some function that's called in
the buffer after its state has changed.

#+begin_note
Of course, ~diff-hl~ is not updated when we commit changes with our ~sendpatch~
utility...
#+end_note

Jump between changes:

#+begin_src emacs-lisp
    ;; Move to Next Change (also on `C-x v ]').
    (define-key diff-hl-mode-map (kbd "C-x v >")      #'diff-hl-next-hunk)
    (define-key diff-hl-mode-map (kbd "M-g <down>")   #'diff-hl-next-hunk)
    (define-key diff-hl-mode-map (kbd "<C-M-S-down>") #'diff-hl-next-hunk) ;; IntelliJ IDEA.

    ;; Move to Previous Change (also on `C-x v [').
    (define-key diff-hl-mode-map (kbd "C-x v <")      #'diff-hl-previous-hunk)
    (define-key diff-hl-mode-map (kbd "M-g <up>")     #'diff-hl-previous-hunk)
    (define-key diff-hl-mode-map (kbd "<C-M-S-up>")   #'diff-hl-previous-hunk) ;; IntelliJ IDEA.
#+end_src

Act on changes:

#+begin_src emacs-lisp
      ;; Popup current diff.
      (define-key diff-hl-mode-map (kbd "C-x v =") #'diff-hl-diff-goto-hunk)

      ;; Revert current hunk (also on `C-x v n').
      (define-key diff-hl-mode-map (kbd "C-x v u") #'diff-hl-revert-hunk)
  )
#+end_src

#+begin_src emacs-lisp :tangle no
    (defun magit-refresh--diff-hl-refresh-after ()
      (dolist (buffer (buffer-list))
        (with-current-buffer buffer
          (when diff-hl-mode
            (diff-hl-update)))))
    (advice-add 'magit-refresh :after #'magit-refresh--diff-hl-refresh-after)
#+end_src

#+begin_src emacs-lisp :tangle no
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
#+end_src

#+begin_tip
Is It Possible To Replace Fringe Bitmaps With Text in Emacs?
http://stackoverflow.com/questions/16114700/is-it-possible-to-replace-fringe-bitmaps-with-text-in-emacs
#+end_tip

** Displaying Boundaries

#+begin_src emacs-lisp
;;** 14.15 (info "(emacs)Displaying Boundaries")

  (leuven--section "14.15 (emacs)Displaying Boundaries")

  ;; Visually indicate buffer boundaries and scrolling in the fringe.
  (setq-default indicate-buffer-boundaries '((top . left) (t . right)))
#+end_src

XXX display-fill-column-indicator-mode in Emacs 27

** Useless Whitespace

#+begin_src emacs-lisp
;;** 14.16 (info "(emacs)Useless Whitespace")

  (leuven--section "14.16 (emacs)Useless Whitespace")
#+end_src

Make trailing whitespace at the end of a line visible.

#+begin_src emacs-lisp
  ;; ;; Highlight trailing whitespaces in all modes.
  ;; (setq-default show-trailing-whitespace t)
#+end_src

Remove trailing whitespace (right trim lines) *in all lines*:

#+begin_src emacs-lisp :tangle no
  ;; Nuke all trailing whitespaces in the buffer.
  (add-hook 'before-save-hook
            #'(lambda ()                  ; Except for ...
                (let ((buffer-undo-list buffer-undo-list)) ; For goto-chg.
                  (unless (or (derived-mode-p 'message-mode)
                                        ; ... where "-- " is the signature
                                        ; separator (for when using emacsclient
                                        ; to compose emails and doing C-x #).
                              (derived-mode-p 'diff-mode))
                                        ; ... where the patch file can't be
                                        ; changed!
                    (delete-trailing-whitespace)))))
#+end_src

This command also deletes all *empty lines at the end of the buffer*.

Remove trailing whitespace *in edited lines* with ~ws-butler~:

#+begin_src emacs-lisp
   ;; Unobtrusively remove trailing whitespace.
   (use-package ws-butler
     :config
     (add-hook 'text-mode-hook #'ws-butler-mode)
     (add-hook 'prog-mode-hook #'ws-butler-mode)
     ;; ;; Remove all tab/space indent conversion.
     ;; (defun ws-butler-clean-region (beg end)
     ;;   "Delete trailing blanks in region BEG END."
     ;;   (interactive "*r")
     ;;   (ws-butler-with-save
     ;;    (narrow-to-region beg end)
     ;;    ;;  _much slower would be:       (replace-regexp "[ \t]+$" "")
     ;;    (goto-char (point-min))
     ;;    (while (not (eobp))
     ;;      (end-of-line)
     ;;      (delete-horizontal-space)
     ;;      (forward-line 1)))
     ;;   ;; clean return code for hooks
     ;;   nil)

     (diminish 'ws-butler-mode)
  )
#+end_src

#+begin_warning
If ~indent-tabs-mode~ is nil, then *tabs in indentation is replaced by spaces* (only
for lines modified by you).
#+end_warning

#+begin_src emacs-lisp
  ;; Visually indicate empty lines after the buffer end in the fringe.
  (setq-default indicate-empty-lines t)
#+end_src

When Whitespace mode is on, it takes care of highlighting some special
characters over the default mechanism of ~nobreak-char-display~ and
~show-trailing-whitespace~.

#+begin_src emacs-lisp
    ;; Enable Whitespace mode in all file buffers (not in *vc-dir*, etc.).
    (add-hook 'text-mode-hook #'whitespace-mode)
    (add-hook 'prog-mode-hook #'whitespace-mode)

    (use-package whitespace
      :ensure nil
      :config
      ;; Which kind of blank is visualized (Show Invisibles).
      (setq whitespace-style
	    '(face
	      trailing
	      tabs
	      ;; lines-tail
	      indentation::space
	      space-mark
	      tab-mark))
      ;; Column beyond which the line is highlighted.
      (setq whitespace-line-column 80)
      ;; Mappings for displaying characters.
      (setq whitespace-display-mappings
	    '((space-mark ?\u00A0         ; No-break space.
			  [?_]            ; Spacing underscore.
			  [?_])           ; Spacing underscore.

	      (space-mark ?\u202F         ; Narrow no-break space.
			  [?\u00B7]       ; Middle dot.
			  [?.])

	      (tab-mark ?\t               ; Tabulation.
			[?\u25BA ?\t]     ; Black right-pointing pointer.
			[?\\ ?\t])))
   )
#+end_src

Example :
VPATH=		/home/jt/src/cygwin/cygwin-packages/1.7/python-2.6.8-2/python-2.6.8-2/src/Python-2.6.8
LDLAST=
SGI_ABI=
PYTHON_OBJS=	\
                Python/pythonrun.o \
                Python/random.o \
                Python/structmember.o

#+begin_src emacs-lisp
  ;; ;; Control highlighting of non-ASCII space and hyphen chars, using the
  ;; ;; `nobreak-space' or `escape-glyph' face respectively.
  ;; (setq nobreak-char-display t)      ; [Default]
#+end_src

#+begin_src emacs-lisp
  ;; ;; Show zero-width spaces.
  ;; (font-lock-add-keywords nil
  ;;  `((,(format "\\(%c\\)" ?\u200B) ; #\ZERO_WIDTH_SPACE
  ;;     (1 (progn (compose-region (match-beginning 1) (match-end 1)
  ;;                               ?\u2B1B ; #\BLACK_LARGE_SQUARE
  ;;                               'decompose-region)
  ;;               nil)))))
#+end_src

** Selective Display

Emacs has the ability to *hide lines indented more than a given number of
columns*.  You can use this to get an overview of a part of a program.

To hide lines with at least 1 column of indentation (replacing them by an
ellipsis), type ~C-1 C-x $~ (or ~C-x $~ and give it ~1~ as depth argument).  It gives
a quick overview any source file.

To make all lines visible again, type ~C-x $~ with no argument.

See also *Outline Mode* for another way to hide part of the text in a buffer.

** Optional Mode Line Features

#+begin_src emacs-lisp
;;** 14.18 (info "(emacs)Optional Mode Line") Features

  (leuven--section "14.18 (emacs)Optional Mode Line Features")

  ;; Show the column number in each mode line.
  (column-number-mode 1)
#+end_src

#+begin_src emacs-lisp
  ;; Unclutter the mode line.
  (use-package diminish
    :config
    (use-package abbrev
      :ensure nil
      :config
      (diminish 'abbrev-mode " Ab")
    )
    (use-package back-button
      :config
      (diminish 'back-button-mode)
    )
    (use-package volatile-highlights
      :config
      (diminish 'volatile-highlights-mode)
    )
    (use-package checkdoc
      :config
      (diminish 'checkdoc-minor-mode " Cd")
    )
    ;; (use-package company"      (diminish 'company-mode " Cp"))
					; Company displays the currently used
					; backend in the mode-line.
    (use-package eldoc
      :config
      (diminish 'eldoc-mode))
    (use-package color-identifiers-mode
      :config
      (diminish 'color-identifiers-mode))
    (use-package fancy-narrow
      :config
      (diminish 'fancy-narrow-mode))
    (use-package flycheck
      :config
      (diminish 'flycheck-mode " fC")) ; Wanna see FlyC:1/1.
    (use-package flyspell
      :config
      (diminish 'flyspell-mode " fS"))
    (use-package google-this
      :config
      (diminish 'google-this-mode))
    (use-package hilit-chg
      :config
      (diminish 'highlight-changes-mode))
    ;; (use-package isearch"      (diminish 'isearch-mode (string 32 ?\u279c)))
    (use-package paredit
      :config
      (diminish 'paredit-mode " Pe"))
    (use-package rainbow-mode
      :config
      (diminish 'rainbow-mode))
    (use-package simple
      :ensure nil
      :config
      (diminish 'auto-fill-function))
    (use-package whitespace
      :config
      (diminish 'whitespace-mode))
    ;; (diminish-on-load hs-minor-mode-hook hs-minor-mode)
    (use-package glasses
      :config
      (diminish 'glasses-mode))
    ;; (use-package redshank"     (diminish 'redshank-mode))
    ;; (use-package smartparens"  (diminish 'smartparens-mode)) ;; Don't hide it, as it impacts perf on big files (must see it!)
    (use-package which-key
      :config
      (diminish 'which-key-mode))
    ;; (with-eval-after-load "whitespace"   (diminish 'whitespace-mode))
  )
#+end_src

See https://powerline.readthedocs.org/en/latest/overview.html#vim-statusline for screenshots.

See https://github.com/bling/vim-airline for the original author.

We build our mode line:

- Git/SVN branch
- buffer-read-only / buffer-modified-p
- mule environment
- buffer name
- which function information
- major mode
- minor modes
- line number, column number
- percent
- buffer size
- dictionary

#+begin_src emacs-lisp
  (defface powerline-modified-face
    '((((class color))
       (:background "#FFA335" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify modified files."
    :group 'powerline)

  (defface powerline-normal-face
    '((((class color))
       (:background "#4F9D03" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify unchanged files."
    :group 'powerline)

  (defface powerline-default-dictionary-active-face
    '((((class color))
       (:background "#8A2BE2" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify default dictionary in the active buffer."
    :group 'powerline)

  (defface powerline-default-dictionary-inactive-face
    '((((class color))
       (:background "thistle" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify default dictionary in inactive buffers."
    :group 'powerline)

  (defface powerline-other-dictionary-active-face
    '((((class color))
       (:background "yellow" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify another dictionary in the active buffer."
    :group 'powerline)

  (defface powerline-other-dictionary-inactive-face
    '((((class color))
       (:background "LightYellow1" :foreground "black" :weight bold))
      (t (:weight bold)))
    "Face to fontify another dictionary in inactive buffers."
    :group 'powerline)

  (defface powerline-buffer-position-face
    '((((class color))
       (:background "#D2D2D2" :foreground "#282828"))
      (t (:weight bold)))
    "Face to fontify buffer position."
    :group 'powerline)

  (defun powerline-simpler-vc-mode (s)
    (if s
        (replace-regexp-in-string "\\(Git\\|SVN\\)[-:]" "" s)
      s))

  (defun powerline-leuven-theme ()
    "Setup the leuven mode-line."
    (interactive)
    (setq-default mode-line-format
     '("%e"
       (:eval
        (let* ((active (powerline-selected-window-active))
               (mode-line (if active
                              'mode-line
                            'mode-line-inactive))
               (face1 (if active
                          'powerline-active1
                        'powerline-inactive1))
               (face2 (if active
                          'powerline-active2
                        'powerline-inactive2))
               (default-dictionary-face
                 (if active
                     'powerline-default-dictionary-active-face
                   'powerline-default-dictionary-inactive-face))
               (other-dictionary-face
                (if active
                    'powerline-other-dictionary-active-face
                  'powerline-other-dictionary-inactive-face))
               (separator-left
                (intern
                 (format "powerline-%s-%s"
                         powerline-default-separator
                         (car powerline-default-separator-dir))))
               (separator-right
                (intern
                 (format "powerline-%s-%s"
                         powerline-default-separator
                         (cdr powerline-default-separator-dir))))
               (lhs (list
                     ;; VC mode.
                     (when (and (fboundp 'vc-switches)
                                buffer-file-name
                                vc-mode)
                       (if (eq (vc-state buffer-file-name) 'up-to-date)
                           (powerline-simpler-vc-mode (powerline-vc 'powerline-normal-face 'r))
                         (powerline-simpler-vc-mode (powerline-vc 'powerline-modified-face 'r))))

                     (when (and (not (fboundp 'vc-switches))
                                buffer-file-name
                                vc-mode)
                       (powerline-simpler-vc-mode (powerline-vc face1 'r)))

                     (when (and buffer-file-name
                                vc-mode)
                       (if (eq (vc-state buffer-file-name) 'up-to-date)
                           (funcall separator-left 'powerline-normal-face mode-line)
                         (funcall separator-left 'powerline-modified-face mode-line)))

                     ;; "Modified" indicator.
                     (if (not (buffer-modified-p))
                         (powerline-raw "%*" nil 'l)
                       (powerline-raw "%*" 'mode-line-emphasis 'l))

                     (powerline-raw mode-line-mule-info nil 'l)

                     (powerline-buffer-id 'mode-line-buffer-id 'l)

                     (when (and (boundp 'which-func-mode) which-func-mode)
                       (powerline-raw which-func-format nil 'l))

                     (powerline-raw " ")
                     (funcall separator-left mode-line face1)
                     (when (boundp 'erc-modified-channels-object)
                       (powerline-raw erc-modified-channels-object face1 'l))
                     (powerline-major-mode face1 'l)
                     (powerline-process face1)
                     (powerline-raw " " face1)
                     (funcall separator-left face1 face2)
                     (powerline-minor-modes face2 'l)
                     (powerline-narrow face2 'l)
                     (powerline-raw " " face2)
                     (funcall separator-left face2 mode-line)))
               (rhs (list (powerline-raw global-mode-string mode-line 'r)
                          (funcall separator-right mode-line face1)
#+end_src

*************** TODO Show column in red when we go over the 80th character
See http://www.elliotglaysher.org/emacs/
*************** END

#+begin_src emacs-lisp
			    (powerline-raw "%l," face1 'l)
			    (powerline-raw "%c" face1 'r)
			    (funcall separator-right face1 'powerline-buffer-position-face)
			    (powerline-raw " %3p" 'powerline-buffer-position-face 'r)
			    (funcall separator-right 'powerline-buffer-position-face face2)
			    (powerline-buffer-size face2 'l)
			    (powerline-raw " " face2)

			    (let ((dict (and (featurep 'ispell)
					     (or
					      ispell-local-dictionary
					      ispell-dictionary))))
			      ;; Add 2 spaces after the language indicator
			      ;; (for GNU/Linux).
			      (cond (buffer-read-only
				     (powerline-raw "%%%%  " default-dictionary-face 'l))
				    ((null dict)
				     (powerline-raw "--  " default-dictionary-face 'l))
				    (t
				     (powerline-raw (concat (substring dict 0 2) "  ") other-dictionary-face 'l))))

			    ;; (powerline-hud face2 face1)
			    )))
	    (concat (powerline-render lhs)
		    (powerline-fill mode-line (powerline-width rhs))
		    (powerline-render rhs)))))))

    (use-package powerline
      :config
      (add-hook 'after-init-hook #'powerline-leuven-theme)
    )
#+end_src

** How Text Is Displayed

#+begin_src emacs-lisp
;;** 14.19 The (info "(emacs)")

  (leuven--section "14.19 (emacs)")

  ;; Display width of a TAB character.
  (setq-default tab-width 4)
#+end_src

** Displaying the Cursor

#+begin_src emacs-lisp
;;** 14.20 The (info "(emacs)Cursor Display")

  (leuven--section "14.20 (emacs)The Cursor Display")
#+end_src

Colorize cursor according to state.

#+begin_src emacs-lisp
  ;; Use cursor color and type to indicate some modes (read-only, overwrite
  ;; and normal insert modes).
  (defun leuven--set-cursor-according-to-mode ()
    "Change cursor color according to some minor modes."
    (let* ((read-only-color "purple1")
           (overwrite-color "#7F7F7F")
           (default-color "black")
           (color (cond (buffer-read-only read-only-color)
                        (overwrite-mode overwrite-color)
                        (t default-color)))
           (type (if (null overwrite-mode) 'bar 'box)))
      (set-cursor-color color)
      (setq cursor-type type)))

  (add-hook 'post-command-hook #'leuven--set-cursor-according-to-mode)

  ;; Cursor to use.
  (setq-default cursor-type 'bar)

  ;; Cursor blinks forever.
  (setq blink-cursor-blinks 0)
#+end_src

Highlight the current line:

#+begin_src emacs-lisp
  ;; Toggle line highlighting in all buffers (Global Hl-Line mode).
  (global-hl-line-mode 1)               ; XXX Perhaps only in prog-modes?

  ;; ;; Extensions to hl-line.el.
  ;; (with-eval-after-load "hl-line+-autoloads"
  ;;
  ;;   ;; Disable Global Hl-Line mode.
  ;;   (global-hl-line-mode -1)
  ;;
  ;;   ;; Turn on `global-hl-line-mode' only when Emacs is idle.
  ;;   (toggle-hl-line-when-idle))

;; hl-line-overlay-priority
  ;; (require 'hl-line+) ; Load this file (it will load `hl-line.el')
#+end_src

** Truncation of Lines

#+begin_src emacs-lisp
;;** 14.21 (info "(emacs)Line Truncation")

  (leuven--section "14.21 (emacs)Line Truncation")

  ;; Respect the value of `truncate-lines' in all windows less than the full
  ;; width of the frame.
  (setq truncate-partial-width-windows nil)
#+end_src

** Customization of Display

#+begin_src emacs-lisp
;;** 14.23 (info "(emacs)Display Custom")ization

  (leuven--section "14.23 (emacs)Display Customization")

  ;; Echo what I'm typing *immediately*.
  (setq echo-keystrokes 0.01)

  ;; Let emacs react faster to keystrokes.
  (setq idle-update-delay 0.35)
#+end_src

Display pressed keyboard shortcuts on screen during presentations or
screencasts.

XXX command-log-mode
XXX view-lossage

#+begin_src emacs-lisp
  ;; Exhaustive log of interactions with Emacs (display keystrokes, etc.).
  (use-package interaction-log
	:load-path "site-lisp"
	:config
	;; ;; Maximum number of lines to keep in the *Emacs Log* buffer.
	;; (setq ilog-log-max 10)

	(defun leuven-display-interaction-log ()
  "Display the Interaction-Log buffer."
      (interactive)
      (interaction-log-mode 1)
      (display-buffer ilog-buffer-name))
	;; Hotkey for showing the log buffer.
	(global-set-key (kbd "C-h C-l") #'leuven-display-interaction-log)
  )
#+end_src

#+begin_note
View-lossage is much improved in Emacs 25, showing directly which commands were
run by each keypress.
#+end_note

#+begin_src emacs-lisp
)                                       ; Chapter 14 ends here.
#+end_src

