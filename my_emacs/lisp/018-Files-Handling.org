* Files Handling

#+begin_src emacs-lisp
;;* 18 (info "(emacs)Files") Handling

(leuven--chapter leuven-load-chapter-18-files "18 Files Handling"
#+end_src

** Visiting Files

#+begin_src emacs-lisp
;;** 18.2 (info "(emacs)Visiting") Files

  (leuven--section "18.2 (emacs)Visiting Files")

  (defadvice find-file (around leuven-find-file-time activate)
    "Advice function for `find-file' that reports the time spent."
    (let ((filename (ad-get-arg 0))
          (find-file-time-start (float-time)))
      (message "[Finding file %s...]" filename)
      ad-do-it
      (message "[Found file %s in %.2f s]" filename
               (- (float-time) find-file-time-start))))

  ;; Visit a file.
  (global-set-key (kbd "<f3>") #'find-file)
#+end_src

#+begin_src emacs-lisp
  ;; Get rid of the "File xxx is large, really open? (y or n)" annoying message.
  (setq large-file-warning-threshold (* 512 1024 1024)) ; 512 MB.

  ;; Maximum buffer size for which line number should be displayed.
  (setq line-number-display-limit large-file-warning-threshold)
                                        ; 14.18 Optional Mode Line Features.
#+end_src

Knowing this kind of behaviour, and especially when trying to guard myself
against reading a log which spits out a long line, I often do something like
~tail -f /some/file | fold -s~ in a shell buffer. This isn't good for editing,
obviously, but helps a lot with reading.

#+begin_src emacs-lisp
  (defun leuven--is-file-large-p ()
    "File is too big and might cause performance issue."
    (> (buffer-size) large-file-warning-threshold))

  ;; View large files.
  (defun leuven--view-large-file ()
    "Fix performance issues in Emacs when viewing large files."
    (setq buffer-read-only t)
    (setq-local bidi-display-reordering nil) ; Default local setting.
    (jit-lock-mode nil)
    (buffer-disable-undo)
    (set (make-variable-buffer-local 'global-hl-line-mode) nil)
    (set (make-variable-buffer-local 'line-number-mode) nil)
    (set (make-variable-buffer-local 'column-number-mode) nil)

    ;; Disable costly modes.
    (when (boundp 'smartparens-mode)
      (smartparens-mode -1))              ; XXX: DOES NOT WORK.
    (when (boundp 'anzu-mode)
      (anzu-mode -1)))

  (define-derived-mode leuven-large-file-mode fundamental-mode "LvnLargeFile"
    "Fix performance issues in Emacs for large files."
    (leuven--view-large-file))

  (add-to-list 'magic-mode-alist (cons #'leuven--is-file-large-p #'leuven-large-file-mode))
#+end_src

#+begin_src emacs-lisp
  (defun leuven-find-large-file-conservatively (filename)
    (interactive
     (list (read-file-name
            "Find file conservatively: " nil default-directory
            (confirm-nonexistent-file-or-buffer))))
    (let ((auto-mode-alist nil))
      (find-file filename)
      (fundamental-mode)
      (leuven--view-large-file)))
#+end_src

The *SoLong* package is a workaround for the issue of large "minified" files of
programming code bringing Emacs to its knees on account of the relevant modes
not being optimised for that use-case.

** Saving Files

You can define a *shadow file* group to automatically upload local files to
a remote location.

#+begin_src emacs-lisp
;;** 18.3 (info "(emacs)Saving") Files

  (leuven--section "18.3 (emacs)Saving Files")

  (defadvice save-buffer (around leuven-save-buffer activate)
    "Save the file named FILENAME and report time spent."
    (let ((filename (buffer-file-name))
          (save-buffer-time-start (float-time)))
      (message "[Saving file %s...]" filename)
      ad-do-it
      (message "[Saved file %s in %.2f s]" filename
               (- (float-time) save-buffer-time-start))))

  ;; Make your changes permanent.
  (global-set-key (kbd "<f2>") #'save-buffer)
#+end_src

Builtin file version control of Emacs.

#+begin_src emacs-lisp
  ;; Make numbered backups.
  (setq version-control t)

  ;; Save backup files (i.e., `foo~' or `foo.~i~') in one central location
  ;; (instead of in the local directory).
  (setq backup-directory-alist
        '((".*" . "~/.emacs.d/backups/")))
                                        ; Filenames matching a regexp are backed
                                        ; up in the corresponding directory.
                                        ; Emacs will `make-directory' it, if
                                        ; necessary.

  ;; ;; Number of oldest versions to keep when a new numbeRed backup is made.
  ;; (setq kept-old-versions 0)            ; [Default: 2]

  ;; Number of newest versions to keep when a new numbered backup is made.
  (setq kept-new-versions 5)            ; [Default: 2]

  ;; Don't ask me about deleting excess backup versions.
  (setq delete-old-versions t)

  ;; Always use copying to create backup files (don't clobber symlinks).
  (setq backup-by-copying t)
#+end_src

Customize saving actions.

Automatically add a newline at the end of the file:

#+begin_src emacs-lisp
  ;; Ensure newline at the end of file when it is saved (in Text or Fundamental mode).
  (defun leuven--text-mode-hook ()
    "Customize `text-mode' buffers."
    (setq-local mode-require-final-newline t))

  (add-hook 'text-mode-hook #'leuven--text-mode-hook)
  (add-hook 'fundamental-mode-hook #'leuven--text-mode-hook)
#+end_src

Update time stamps (and copyright notice) automatically.

#+begin_src emacs-lisp
  ;; Update time stamps every time you save a buffer.
  (add-hook 'before-save-hook #'time-stamp)

  ;; Maintain last change time stamps (`Time-stamp: <>' occurring within
  ;; the first 8 lines) in files edited by Emacs.
  (with-eval-after-load "time-stamp"

    ;; Format of the string inserted by `M-x time-stamp':
    ;; `YYYY-MM-DD Day HH:MM' (see `system-time-locale' for non-numeric
    ;; formatted items of time).
    (setq-default time-stamp-format "%:y-%02m-%02d %3a %02H:%02M"))

  ;; Update the copyright notice to indicate the current year.
  (add-hook 'before-save-hook
            #'(lambda ()                  ; Except for ...
                (unless (derived-mode-p 'diff-mode)
                                        ; ... where the patch file can't be
                                        ; changed!
                  (copyright-update))))
#+end_src

** Reverting a Buffer

#+begin_src emacs-lisp
;;** 18.4 (info "(emacs)Reverting") a Buffer

  (leuven--section "18.4 (emacs)Reverting a Buffer")

  ;; Time between Auto-Revert Mode file checks.
  (setq auto-revert-interval 1)         ; [Default: 5]

  ;; ;; But if, for instance, a new version is checked in from outside the current
  ;; ;; Emacs session, the version control number in the mode line, as well as
  ;; ;; other version control related information, may not be properly updated
  ;; (setq auto-revert-check-vc-info t)

  ;; Synchronize.  Reload the file from disk (replacing current buffer text with
  ;; the text of the visited file on disk).
  (defun leuven-revert-buffer-without-query ()
    "Unconditionally revert current buffer."
    (interactive)
    (revert-buffer t t)                 ; ignore-auto(-save), noconfirm
    ;; Remove highlights.
    (dolist (o (overlays-in (window-start) (window-end)))
      (when (or (equal (overlay-get o 'face) 'recover-this-file)
                (equal (overlay-get o 'face) 'highlight-changes)
                (equal (overlay-get o 'face) 'highlight-changes-delete)
                (equal (overlay-get o 'face) 'org-block-executing))
        (delete-overlay o)))            ; Useful when our advice of function
                                        ; `org-babel-execute-src-block' fails to
                                        ; remove the background color.
    (message "[Buffer is up to date with file on disk]"))

  (global-set-key (kbd "C-S-y") #'leuven-revert-buffer-without-query)
#+end_src

Turn on auto-revert mode globally.

#+begin_src emacs-lisp
  (when leuven--cygwin-p                ; Cygwin Emacs uses gfilenotify (based
                                        ; on GLib) and there are performance
                                        ; problems... Emacs bug 20927

    ;; Don't use file notification functions.
    (setq auto-revert-use-notify nil))  ; XXX Apply this in EmacsW32 if it doesn't revert!

  ;; Enable Global Auto-Revert mode (auto refresh buffers).
  (idle-require 'autorevert)
  (with-eval-after-load "autorevert"
    (global-auto-revert-mode 1))        ; Can generate a lot of network traffic
                                        ; if `auto-revert-remote-files' is set
                                        ; to non-nil.
#+end_src

Auto-revert will automatically *reload files* that have been *modified outside of
Emacs* (externally modified files).  It won't revert a buffer that you've edited
inside Emacs, even if the file also changes outside.

#+begin_warning
~global-auto-revert-mode~ blocks Cygwin Emacs for more than 5 seconds at many
points in time. Disabled for now, under Cygwin.
#+end_warning

** Auto Reverting Non-File Buffers

Auto-refresh Dired.

#+begin_src emacs-lisp
  ;; Global Auto-Revert mode operates on all buffers (Dired, etc.)
  (setq global-auto-revert-non-file-buffers t)

  ;; Do not generate any messages (be quiet about refreshing Dired).
  (setq auto-revert-verbose nil)        ; Avoid "Reverting buffer `some-dir/'.".
#+end_src

** Auto-Saving: Protection Against Disasters

How to get Emacs to auto-save to your local disk (=#file#=).

#+begin_src emacs-lisp
;;** 18.6 (info "(emacs)Auto Save"): Protection Against Disasters

  (leuven--section "18.6 (emacs)Auto Save: Protection Against Disasters")

  ;; Auto-save every 100 input events.
  (setq auto-save-interval 100)         ; [Default: 300].

  ;; Save files automatically if application is idle for 15 sec.
  (setq auto-save-timeout 15)           ; [Default: 30].
#+end_src

Disable backups and auto-save only in the current buffer with
~M-x sensitive-mode~:

#+begin_src emacs-lisp
  (define-minor-mode sensitive-mode
    "For sensitive files like password lists.
  It disables backup creation and auto saving in the current buffer.

  With no argument, this command toggles the mode.  Non-null prefix argument
  turns on the mode.  Null prefix argument turns off the mode."
    :init-value nil                     ; Initial value.
    :lighter " Sensitive"               ; Indicator for the mode line.
    :keymap nil                         ; Minor mode bindings.
    (if (symbol-value sensitive-mode)
        (progn
          ;; Disable backups.
          (set (make-local-variable 'backup-inhibited) t)
          ;; Disable auto-save.
          (if auto-save-default
              (auto-save-mode -1)))
      ;; Resort to default value of backup-inhibited.
      (kill-local-variable 'backup-inhibited)
      ;; Resort to default auto save setting.
      (if auto-save-default
          (auto-save-mode 1))))
#+end_src

You should enable it for all =.vcf= and =.gpg= files.

Make the message "/FILENAME has auto save data/" unmissable:

#+begin_src emacs-lisp
  (defface recover-this-file
    '((t :weight bold :background "#FF3F3F"))
    "Face for buffers visiting files with auto save data."
    :group 'files)

  (defvar leuven--recover-this-file nil
    "If non-nil, an overlay indicating that the visited file has auto save data.")

  (defun leuven--recover-this-file ()
    (let ((warn (not buffer-read-only)))
      (when (and warn
                 ;; No need to warn if buffer is auto-saved under the name of
                 ;; the visited file.
                 (not (and buffer-file-name
                           auto-save-visited-mode)) ; Emacs 26.1
                 (file-newer-than-file-p (or buffer-auto-save-file-name
                                             (make-auto-save-file-name))
                                         buffer-file-name))
        (set (make-local-variable 'leuven--recover-this-file)
             (make-overlay (point-min) (point-max)))
        (overlay-put leuven--recover-this-file
                     'face 'recover-this-file))))

  (add-hook 'find-file-hook #'leuven--recover-this-file)
#+end_src

XXX Add explanation about what to do when a file is opened in red background!

** Comparing Files

See https://www.diffchecker.com/diff for an online solution.

*** Diff

If you want a Magit diff buffer for the current file, you can call
magit-diff-buffer-file directly, or use the "diff" option (d) in
magit-file-popup. e.g.:

(global-set-key (kbd "C-c m d") #'magit-diff-buffer-file)
(global-set-key (kbd "C-c m f") #'magit-file-popup)

#+begin_tip
To compare Excel files, go to =File= / =Options= / =Advanced= / =Display options for
this worksheet= / =Show formulas in cells instead of their calculated
results=.  Then, =File= / =Save As= / =CSV=.

Or, even easier, use *Spreadsheet Compare 2016*!
#+end_tip

#+begin_src emacs-lisp
;;** 18.9 (info "(emacs)Comparing Files")

  (leuven--section "18.9 (emacs)Comparing Files")

  ;; ;; Default to unified diffs.
  ;; (setq diff-switches "-u")             ; Default in Emacs 25.
#+end_src

Press ~e~ in Dired mode to immediately Ediff two marked files, no questions asked:

#+begin_src emacs-lisp
  (defun leuven-ediff-files-from-dired ()
"Quickly Ediff files from Dired"
    (interactive)
    (let ((files (dired-get-marked-files))
          (wnd (current-window-configuration)))
      (if (<= (length files) 2)
          (let ((file1 (car files))
                (file2 (if (cdr files)
                           (cadr files)
                         (read-file-name
                          "File B to compare: "
                          (dired-dwim-target-directory)))))
            (if (file-newer-than-file-p file1 file2)
                (ediff-files file2 file1)
              (ediff-files file1 file2))
            (add-hook 'ediff-after-quit-hook-internal
                      #'(lambda ()
                          (setq ediff-after-quit-hook-internal nil)
                          (set-window-configuration wnd))))
        (error "no more than 2 files should be marked"))))

  (with-eval-after-load "dired"
    (define-key dired-mode-map (kbd "E") #'leuven-ediff-files-from-dired))
#+end_src

- In case no files are marked, the file at point is used as the first file, and
  ~read-file-name~ is used for the second file. Since I have the magic
  (setq dired-dwim-target t)
  in my config, in case a second dired buffer is open,
  ~dired-dwim-target-directory~ will offer it as the starting directory during
  completion. Very useful to compare two files in two different directories.

- Depending on the order of the arguments to ~ediff-files~, the changes will
  appear either as added or removed; ~file-newer-than-file-p~ tries to put the
  arguments in a logical order by looking at the files' last change times.

- ~ediff-after-quit-hook-internal~ is used to restore the previous window
  configuration after I quit Ediff with ~q~.

*** Compare windows

#+begin_src emacs-lisp
  ;; Compare text in current window with text in next window.
  (global-set-key (kbd "C-=") #'compare-windows)
#+end_src

*** SMerge mode

You can use ~M-x smerge-mode~ to *edit a file with conflict markers* (output from
the ~diff3~ program).

SMerge does not automatically select regions but provides convenient key
bindings to navigate between conflicts and to choose the A or B variant.

#+begin_src emacs-lisp
  ;; Change the cumbersome default prefix (C-c ^).
  (setq smerge-command-prefix (kbd "C-c v"))
#+end_src

Important keybindings:

- ~C-c v n~ (~smerge-next~) ::
     Move to next conflict.

- ~C-c v p~ (~smerge-previous~) ::
     Move to previous conflict.

- ~C-c v RET~ (~smerge-keep-current~) ::
     Keep the version the cursor is on.

- ~C-c v m~ (~smerge-keep-mine~) ::
     Keep your changes.

- ~C-c v o~ (~smerge-keep-other~) ::
     Keep other changes.

#+begin_src emacs-lisp :tangle no
  ;; Enable SMerge automatically.
  (defun leuven--enable-smerge-maybe ()
    (when (and buffer-file-name (vc-backend buffer-file-name))
      (save-excursion
        (goto-char (point-min))
        (when (re-search-forward "^<<<<<<< " nil t)
          (smerge-mode 1)))))

  (add-hook 'buffer-list-update-hook #'leuven--enable-smerge-maybe)
#+end_src

#+begin_note
In recent Emacs versions, SMerge is turned on automatically??? XXX
#+end_note

*** Interface for merging files

- ~C-c v E~ (~smerge-ediff~) ::
     Start an Ediff session to merge the conflicts.

Keybindings:

- ~n~ and ~p~ ::
     Navigate through the conflicts.

- ~a~ or ~b~ ::
     Accept versions.

- ~/~ ::
     Look at the ancestor!

- ~q~ ::
     Quit the ediff session.

The top-left pane contains the =file= in my working directory as it was before the
merge, the top-right pane contains the final revision of =file= at the source URL
and the bottom pane contains the merged version.

The really nice thing is that as soon as I end the Ediff session, Emacs goes
back to the conflicted file /with all the changes done in the Ediff session
applied/. So if you have resolved all conflicts, the file is not in Smerge mode
anymore. The only thing left to do is to save the file. After that, the state of
the file as displayed in the vc-dir buffer changes from /conflicted/ to /edited/.

#+begin_note
Since the year 2000, ~vc-resolve-conflict~ is an alias for ~smerge-ediff~, which as
the name suggests starts an Ediff session, not an Emerge session.

By the way, the library header of =ediff.el= acknowledges =emerge.el='s influence
and then goes on saying "The present version of *Ediff supersedes Emerge*.  It
provides a superior user interface and has numerous major features not found in
Emerge.  In particular, it can do patching, and 2-way and 3-way file comparison,
merging, and directory operations."

Also note that ~magit-ediff-resolve~ (~E m~ or ~e~ on a file with conflicts) uses
~smerge-ediff~ internally.  It does however override the ~ediff-quit-hook~ to
provide a slightly better session finishing experience.  Instead of telling you
that you could save "the buffer" (there are several buffers), it asks you
whether you want to save the buffer (while showing you its name).
#+end_note

** Diff mode

You can review the diff of all file changes, either:

- *unified* (Diff mode) or
- *split* (Ediff mode).

In Diff mode, the changes specified in a patch are grouped into "hunks", which
are contiguous chunks of text that contain one or more changed lines.

Use ~C-x v =~ to show what's changed.

You can also decide to revert a change: *select a hunk and apply it (in reverse)*.

#+begin_src emacs-lisp
  ;;** 18.10 (info "(emacs)Diff Mode")

	(leuven--section "18.10 (emacs)Diff Mode")

	;; Mode for viewing/editing context diffs.
	(use-package "diff-mode"
	  :ensure nil
	  :config
	  ;; Highlight the changes with better granularity.
	  (defun leuven-diff-make-fine-diffs ()
		"Enable Diff Auto-Refine mode."
		(interactive)
		(let (diff-refine)                ; Avoid refining the hunks redundantly ...
		  (condition-case nil
			  (save-excursion
				(goto-char (point-min))
				(while (not (eobp))
				  (diff-hunk-next)
				  (diff-refine-hunk)))    ; ... when this does it.
			(error nil))
		  (run-at-time 0.0 nil
					   #'(lambda ()
						   (if (derived-mode-p 'diff-mode)
							   ;; Put back the cursor only if still in a Diff buffer
							   ;; after the delay.
							   (goto-char (point-min)))))))

	  (defun vc-diff--diff-make-fine-diffs-if-necessary (&optional historic not-urgent)
		"Auto-refine only the regions of 14,000 bytes or less."
		;; Check for auto-refine limit.
		(unless (> (buffer-size) 14000)
		  (leuven-diff-make-fine-diffs)))
	  ;; Push the auto-refine function after `vc-diff'.
	  (advice-add 'vc-diff :after #'vc-diff--diff-make-fine-diffs-if-necessary)
#+end_src

If you use ~colordiff~ in SVN, you need this:

#+begin_src emacs-lisp
    (defun vc-diff-finish--handle-color-in-diff-output (buffer messages &optional oldbuf)
      "Run `ansi-color-apply-on-region'."
      (interactive)
      (progn
        (require 'ansi-color)
        (let ((inhibit-read-only t))
          (ansi-color-apply-on-region (point-min) (point-max)))))
    (advice-add 'vc-diff-finish :after #'vc-diff-finish--handle-color-in-diff-output)
#+end_src

#+begin_src emacs-lisp
    )
#+end_src

To compare 2 text files, you can also use Ediff if the following command
works.

: M-: (executable-find "diff") RET

In Ediff, press:

- ~?~ to get help

- ~|~ to change from vertical window layout to horizontal window layout, and
  vice versa

- ~a~ or ~b~ key to merge the code from A to B or from B to A

- ~ra~ or ~rb~ to revert your change

#+begin_src emacs-lisp
  ;; ;; Ediff, a comprehensive visual interface to diff & patch
  ;; ;; setup for Ediff's menus and autoloads
  ;; (try-require 'ediff-hook)
  ;; already loaded (by Emacs?)

  (use-package "ediff"
	:ensure nil
	:config
	;; Ignore space.
	(setq ediff-diff-options (concat ediff-diff-options " -w"))
										; Add new options after the default ones.

	;; Skip over difference regions that differ only in white space and line
	;; breaks.
	;; (setq-default ediff-ignore-similar-regions  t)
	;; XXX Make another key binding (than `E') with that value in a let-bind

	;; Sometimes grab the mouse and put it in the control frame.
	(setq ediff-grab-mouse 'maybe)

	;; Do everything in one frame.
	(setq ediff-window-setup-function 'ediff-setup-windows-plain)

	;; Split the window (horizontally or vertically) depending on the frame
	;; width.
	(setq ediff-split-window-function
		  #'(lambda (&optional arg)
			  (if (> (frame-width) split-width-threshold)
				  (split-window-horizontally arg)
				(split-window-vertically arg))))

	;; (setq ediff-merge-split-window-function 'split-window-vertically)
#+end_src

When using Ediff, everything must be visible; otherwise, it's fairly hard to
resolve conflicts.

#+begin_src emacs-lisp
    (defun turn-on-visible-mode ()
      "Make all invisible text visible."
      (visible-mode 1)
      (setq truncate-lines nil)
      (when (and (boundp 'hs-minor-mode)
                 hs-minor-mode)
        (hs-show-all))
      (when (derived-mode-p 'org-mode)
        (org-remove-inline-images)))

    ;; Force the buffers to unhide (folded) text (in Org files).
    (add-hook 'ediff-prepare-buffer-hook #'turn-on-visible-mode)

    (defun turn-off-visible-mode ()
      "Disable Visible mode."
      (visible-mode 0)
      (setq truncate-lines t)
      (when (derived-mode-p 'org-mode)
        (org-display-inline-images)))

    (add-hook 'ediff-quit-hook #'turn-off-visible-mode)

    )
#+end_src

*** Ediff-directories

For *comparing two directories*, you can use ~ediff-directories~, ~ztree-diff~, [[http://meldmerge.org/][Meld]]
(free) or [[https://www.deltawalker.com/][DeltaWalker]] (39.95 USD).

~ediff-directories~ combined with the key sequence == h x= ~= h x~ shows you only the
files which differ.

It is not recursive, but it gives you also subdirectory pairs to compare.  Just
hit ~RET~ on such a pair.

As bonus, it even works for remote directories.

#+begin_warning
~ediff-directories~ does not list files in one directory with no corresponding
files in the other directory.
#+end_warning

*** Ztree

#+begin_src emacs-lisp
  ;; ("M-m g v" . ztree-dir)
  ;; ("M-m g V" . ztree-diff)
#+end_src

Hotkeys supported:

- Open/close directories with double-click, ~RET~ or ~SPC~ keys.
- To jump to the parent directory, hit the ~Backspace~ key.
- To toggle open/closed state of the subtree of the current directory, hit the
  ~x~ key.
- ~RET~ on different files starts the *Ediff* (or open file if one absent or the same)
- ~SPC~ show the simple diff window for the current file instead of *Ediff* (or view
  file if one absent or the same)
- ~TAB~ to fast switch between panels
- ~h~ key to toggle show/hide identical files/directories
- ~H~ key to toggle show/hide hidden/ignored files/directories
- ~C~ key to copy current file or directory to the left or right panel
- ~D~ key to delete current file or directory
- ~v~ key to quick view the current file
- ~r~ initiates the rescan/refresh of current file or subdirectory
- ~<F5>~ forces the full rescan.

** Miscellaneous File Operations

#+begin_src emacs-lisp
;;** 18.11 (info "(emacs)Misc File Ops")

  (leuven--section "18.11 (emacs)Misc File Ops")

  ;; Use the system's Trash (when it is available).
  (setq delete-by-moving-to-trash t)
#+end_src

** Accessing Compressed Files

- Display the *contents* of the archive
- *View or edit* the actual files contained withing the archive

Using the Emacs Dired utility, you can compress (individually) or uncompress
marked files (using ~gzip~) by pressing ~Z~.

If you want to create *a single archive* file from many marked files, you can use
~dired-do-compress-to~, bound to ~c~.

*** On Windows                                                        :noexport:

On Windows, if you are trying to use ~gunzip~ to uncompress a file under Dired,
you will probably encounter errors.

The problem is due to that ~gunzip~ provided by Cygwin is not an executable
file.  It is a *symbolic link to ~gzip~*; you can verify this by
~ls -l /usr/bin/gunzip~.

Since *GNU Emacs does not understand Cygwin's symbolic links*, it cannot execute
~gunzip~.  The solution is to replace ~gunzip~ with ~gzip -d~.

#+begin_src shell :tangle ~/winbin/gunzip :padline no
#!/bin/sh
# gunzip -- gunzip solution on Windows

PATH=${GZIP_BINDIR-'/usr/bin'}:$PATH
exec gzip -d "$@"

# gunzip ends here
#+end_src

** Auto Encryption

History:

1. mailcrypt

2. PGG

3. EasyPG (= epg) is a GnuPG interface for Emacs.

   It allows you to encrypt/decrypt files within Emacs.  When you use ~C-x C-f~ to
   access an encrypted file, Emacs prompts you for the passphrase and then
   decrypts the file before displaying it.  When you save the file, Emacs
   automatically encrypts it again with that same key.

   It has two aspects:

   - convenient tools which allow to use GnuPG from Emacs (EasyPG Assistant),
     and

   - a fully functional interface library to GnuPG (EasyPG Library).

*************** TODO Fetch the key automatically
Set the ~keyserver~ entry in the =~/.gnupg/gpg.conf= file properly.
*************** END

What is PGP/MIME, what is OpenPGP, and how Gnus handles them?
- PGP/MIME is a standard, which mml2015* implements using ep[ag]-*.
- OpenPGP is a standard, which ep[ag]-* implements.

#+begin_src emacs-lisp
  ;; The EasyPG Assistant, transparent file encryption.
  (use-package "epa-file"
	:config
	(custom-set-variables '(epg-gpg-program "gpg2"))
										; If you have issues, try uninstalling
										; gnupg, keeping only gnupg2!

	;; Stop EasyPG from asking for the recipient used for encrypting files.
	(setq epa-file-encrypt-to (if (boundp 'user-mail-address)
								  user-mail-address
								'("john.doe@example.com")))
										; If no one is selected (""), symmetric
										; encryption will always be performed.

	;; Cache passphrase for symmetric encryption (VERY important).
	(setq epa-file-cache-passphrase-for-symmetric-encryption t)
										; Not to sound paranoid.  But if you
										; want caching, it's recommended to use
										; *public-key encryption* instead of
										; symmetric encryption.  `gpg-agent' is
										; the preferred way to do this.

	;; Query passphrase through the minibuffer, instead of using an external
	;; Pinentry program.
	(setenv "GPG_AGENT_INFO" nil)
	(setq epa-pinentry-mode 'loopback)

	;; Enable `epa-file'.
	(epa-file-enable))
#+end_src

Password free

Otherwise:

#+begin_src shell :tangle no
gpgconf kill gpg-agent
#+end_src

** Remote Files

#+begin_src emacs-lisp
;;** 18.14 (info "(emacs)Remote Files")

  (leuven--section "18.14 (emacs)Remote Files")
#+end_src

*** Ange-FTP

*************** TODO Check out why network share aren't accessible
I should be able to open //SERVER/d/ via SMB!?
*************** END

#+begin_src emacs-lisp
  ;;*** Ange-FTP

	(leuven--section "Ange-FTP")

	;; Transparent FTP support.
	(use-package "ange-ftp"
	  :config
	  ;; Try to use passive mode in ftp, if the client program supports it.
	  (setq ange-ftp-try-passive-mode t)) ; Needed for Ubuntu.
#+end_src

*** TRAMP

Open files on a remote machine using [[http://www.gnu.org/software/tramp/][TRAMP]] (other protocols than just FTP) from
your machine, edit and save them!

~/method:user@host:/path/to/some/file~

Examples:
- ~C-x C-f /ssh:user@host:/etc/motd RET~ (~root~ to modify it!)
- ~C-x C-f /plink:user@host:/etc/motd RET~ (from Windows Emacs)
- ~C-x C-f /sudo:root@localhost:/etc/motd RET~
- ~C-x C-f /su::/etc/motd RET~ (shortened syntax for the ~root~ account on the
  local host)

Also ~M-x find-dired~, ~rgrep~, ~lgrep~, ~compile -~ properly work with TRAMP (run on
remote server and show result in your Emacs).

#+begin_note
~sshfs~ can give you the same functionality as TRAMP: it is like a personal NFS
(another mounted file system) over SSH.  If you can SSH to a server, you can
probably do ~sshfs~.
#+end_note

#+begin_src emacs-lisp
  ;;*** TRAMP - Transparent Remote Access, Multiple Protocols

	(leuven--section "TRAMP")

	(use-package "tramp"         ; The autoloads are predefined.
	:ensure nil
	:config
#+end_src

**** TODO Configuring TRAMP for use

***** Selecting a default method

#+begin_note
As there are *issues with Cygwin ~ssh~* (which only works with Cygwinized Emacs),
*Windows users* should use the PuTTY implementation of SSH (~plink~ method).
#+end_note

#+begin_src emacs-lisp
    ;; Default transfer method.
    (setq tramp-default-method          ; [Default: "scp"]
          (cond (leuven--win32-p "plink")
                (t "ssh")))
#+end_src

#+begin_tip
You might try out the ~rsync~ /external/ method, which saves the remote files quite
a bit faster than SSH.  It's based on SSH, so it works the same, just saves
faster.
#+end_tip

***** Find file as root

You can just do ~C-x C-f /sudo:user@localhost:/etc/motd RET~.

Because I'm lazy, I have a hack (from Tassilo Horn): if I try to open a file
for which I don't have permissions for, I'm queried if I want to open it as
root using the ~sudo~ tramp method.

#+begin_src emacs-lisp
    (defun leuven--find-file-sudo-header-warning ()
      "*Display a warning in header line of the current buffer."
      (let* ((warning "WARNING: EDITING FILE WITH ROOT PRIVILEGES!")
             (space (+ 6 (- (frame-width) (length warning))))
             (bracket (make-string (/ space 2) ?-))
             (warning (concat bracket warning bracket)))
        (setq header-line-format
              (propertize warning 'face 'header-line))))

    (defun leuven-find-file-sudo (filename)
      "Open FILENAME with root privileges."
      (interactive "F")
      (set-buffer (find-file (concat "/sudo::" filename)))
      (leuven--find-file-sudo-header-warning))

    (defadvice find-file (around leuven-find-file-sudo activate)
      "Advice function for `find-file' that opens FILENAME with root privileges
using Tramp's sudo method if it's read-only."
      (if (and (file-exists-p (ad-get-arg 0))
               (not (file-writable-p (ad-get-arg 0)))
               (not (file-remote-p (ad-get-arg 0)))
               (y-or-n-p (concat "File "
                                 (ad-get-arg 0)
                                 " is read-only.  Open it as root? ")))
          (leuven-find-file-sudo (ad-get-arg 0))
        ad-do-it))
#+end_src

***** Connecting to a remote host using multiple hops

New proxy system (introduced in 2004, instead of the old "multi-hop" methods) to
edit files on a remote server by going via another server.

#+begin_example
    ;; Route to be followed for specific host/user pairs.
    (add-to-list 'tramp-default-proxies-alist
                 ;;  "final host"    "user"    "proxy in the middle"
                 '("10.10.13.123" "\\`root\\'" "/ssh:%h:"))
#+end_example

Opening ~/sudo:10.10.13.123:~ would connect first ~10.10.13.123~ via ~ssh~ under your
account name, and perform ~sudo -u root~ on that host afterwards.  It is important
to know that the given method is applied on the host which has been reached so
far.  The trick is to think from the end.

***** Reusing passwords for several connections

#+begin_src emacs-lisp
    ;; How many seconds passwords are cached.
    (setq password-cache-expiry 60)     ; [Default: 16]
#+end_src

***** Remote shell setup hints

It is worth noting that you can customize the prompt that tramp expects
(~tramp-login-prompt-regexp~) but my advice would rather be to make your prompt
TRAMP-compatible and not the other way around.

*The author of TRAMP doesn't think this ever needs to be changed, so please tell
him about it if you need to change this.*

#+begin_src emacs-lisp :tangle no
    ;; String used for end of line in rsh connections.
    (setq tramp-rsh-end-of-line         ; [Default: "\n"]
          (cond (leuven--win32-p "\n")
                (t "\r")))
#+end_src

***** Auto-save and Backup configuration

#+begin_src emacs-lisp
    ;; "Turn off" the effect of `backup-directory-alist' for TRAMP files.
    (add-to-list 'backup-directory-alist
                 (cons tramp-file-name-regexp nil))

    ;; Faster auto saves.
    (setq tramp-auto-save-directory temporary-file-directory)
#+end_src

**** Frequently Asked Questions

Be notified when TRAMP file transfers are complete by making Emacs beep after
reading from or writing to the remote host.

#+begin_src emacs-lisp
    (defadvice tramp-handle-write-region
      (after leuven-tramp-write-beep-advice activate)
      "Make TRAMP beep after writing a file."
      (interactive)
      (beep))

    (defadvice tramp-handle-do-copy-or-rename-file
      (after leuven-tramp-copy-beep-advice activate)
      "Make TRAMP beep after copying a file."
      (interactive)
      (beep))

    (defadvice tramp-handle-insert-file-contents
      (after leuven-tramp-insert-beep-advice activate)
      "Make TRAMP beep after inserting contents of a file."
      (interactive)
      (beep))
#+end_src

**** How to Customize Traces

The usual way to debug TRAMP is to set ~tramp-verbose~ to 6.  This will produce a
debug buffer, which you can show at ~tramp-devel@gnu.org~.

#+begin_src emacs-lisp
    ;; Debugging TRAMP.
    (setq tramp-verbose 6))             ; [Maximum: 10]
#+end_src

The best way to report a TRAMP bug is to call ~M-x tramp-bug~; this prepares an
email, including several trace information for analysis.

** Convenience Features for Finding Files

#+begin_src emacs-lisp
  ;;** 18.17 (info "(emacs)File Conveniences")

	(leuven--section "18.17 (emacs)File Conveniences")

	;; Filenames excluded from the recent list.
	(setq recentf-exclude                 ; Has to be set before you require
										  ; `recentf'!
		  '(
			".recentf"
			"~$"                          ; Emacs (and others) backup.
			"\\.aux$" "\\.log$" "\\.toc$" ; LaTeX.
			"/tmp/"
			))

	;; Setup a menu of recently opened files.
	(use-package "recentf"
	  :config
	  ;; Maximum number of items that will be saved.
	  (setq recentf-max-saved-items 300)  ; Just 20 is too recent.

	  ;; File to save the recent list into.
	  (setq recentf-save-file (concat user-emacs-directory ".recentf"))

	  ;; (When using TRAMP) turn off the cleanup feature of `recentf'.
	  (setq recentf-auto-cleanup 'never)  ; Disable before we start recentf!

	  ;; Save file names relative to my current home directory.
	  (setq recentf-filename-handlers '(abbreviate-file-name))

	  ;; Enable `recentf' mode.
	  (recentf-mode 1))
#+end_src

*** Helm
:PROPERTIES:
:ID:       59418189-b87e-45a2-b128-5cbdc8a16430
:END:

**** What is Helm?

Helm (successor of Anything) is an incremental completion and selection
narrowing framework for Emacs.

It will help *steer* you in the right direction when you're looking for stuff in
Emacs (like buffers, files, etc).  You don't have anymore to remember the
structure of your working directory; you can focus on more important things.

**** How does it work?

The /default/ prefix for the preconfigured Helm commands is ~C-x c~.  In
Emacs-Leuven, we changed it to ~C-c h~.

#+begin_note
We cannot change ~helm-command-prefix-key~ once ~helm-config~ is loaded.
#+end_note

#+begin_src emacs-lisp
  (leuven--section "Helm")
  (use-package helm
	:config
  ;; Change `helm-command-prefix-key'.
	(global-set-key (kbd "C-c h") #'helm-command-prefix)
	(global-unset-key (kbd "C-x c"))
	;; Resume a previous `helm' session.
    (global-set-key (kbd "C-M-z") #'helm-resume)

#+end_src
In Helm, generally, look at the *mode line*: you will see ~C-h m:Help~, it is your
friend; hit it for more info.

In default Helm:

- Narrow the list by typing some patterns (use the *space as separator* for
  multiple patterns),

- Select an element with ~<Up>~ / ~<Down>~ / ~<PageUp>~ / ~<PageDown>~ / ~C-p~ / ~C-n~ /
  ~C-v~ / ~M-v~,

- Choose with ~RET~.

- ~C-z~ executes an action without quitting the Helm session (persistent action).

  #+begin_note
  For ~helm-find-files~:

  + On a regular file,
    1. First hit on ~C-z~ expands the file name
    2. Second hit opens the file and displays its contents in the other window
    3. Third hit kills the buffer (unless it was already open before starting
       helm session).

  + On image files (~.jpg~, etc..)
    1. Second hit (or ~C-u C-z~) displays the image in the other window
    2. If you then turn on ~helm-follow-mode~ (~C-c C-f~), you turn on Helm in
       *image browser* (i.e., use ~C-n/p~ or arrows ~down/up~).
    3. You can rotate image with ~M-l/r~ (these are persistent actions too).
  #+end_note

Kill your buffers with ~C-u C-z~ one by one.

To go back to the *previous element* of the minibuffer history, use ~M-p~.

To mark all candidates in a Helm buffer, use ~M-a~ (~helm-mark-all~) or ~M-m~
(~helm-toggle-all-marks~).

Switch to ~*Helm Log*~ buffer with ~M-x helm-open-last-log~.

**** Changes in key bindings

In ~helm-find-file~, you may want to try using the left arrow to go to the parent
directory!

You can reassign ~TAB~ only during ~helm-find-file~.  The ~helm-find-file~ almost
looks like Dired and I assign ~^~ for going up.  Minor side effect is you cannot
type in ~^~ without using ~C-q~.

Sometimes you want to hit ~TAB~ for ~helm-selection-action~; however, you chose not
to happen.  Now look for substitute for ~TAB~.  Something not ~TAB~ can be ~C-z~,
~C-TAB~, and ~SPC~.

#+begin_src emacs-lisp :tangle no
(define-key helm-find-files-map (kbd "<C-tab>") #'helm-select-action)
(define-key helm-find-files-map (kbd "<SPC>")   #'helm-select-action)
(define-key helm-find-files-map (kbd "<RET>")   #'helm-confirm-and-exit-minibuffer)
(define-key helm-find-files-map (kbd "^")       #'helm-find-files-up-one-level)
#+end_src

#+begin_src emacs-lisp :tangle no
(define-key helm-grep-mode-map (kbd "<RET>") #'helm-grep-mode-jump-other-window)
(define-key helm-grep-mode-map (kbd "n") #'helm-grep-mode-jump-other-window-forward)
(define-key helm-grep-mode-map (kbd "p") #'helm-grep-mode-jump-other-window-backward)
#+end_src

**** Helm documentation

- *Advanced usage* on [[https://github.com/emacs-helm/helm#advanced-usage][Emacs-helm]] page
- [[https://github.com/emacs-helm/helm/wiki][Emacs-helm wiki]]
- [[https://github.com/thierryvolpiatto/emacs-tv-config/blob/master/init-helm-thierry.el][Helm configuration file of Thierry Volpiatto]]!
- http://tuhdo.github.io/helm-intro.html

Helm allows you to do interesting things with its interactive interface. For
example:

- interactive grep: http://tuhdo.github.io/static/live_grep.gif
- interactive occur: http://tuhdo.github.io/static/part3/helm-occur.gif

**** Vocabulary

- ~volatile~ means your candidates are recomputed each time you enter a character
  in pattern (cached candidates are not reused).  Async sources are by essence
  volatile.

- ~delayed~ means your candidates are computed after ~helm-input-idle-delay~
  seconds.

- ~no-matchplugin~ means to not use the multi regexp matching provided by
  ~helm-match-plugin.el~.

**** Features

Finally, the strings in Helm are not just strings; they are *regexps* and I think
they are more powerful than normal fuzzy matcher.

Grep in Helm is interactive, unlike the stock grep/rgrep.
Demo: http://tuhdo.github.io/static/live_grep.gif

No package does any of this:

- Live grep: http://tuhdo.github.io/static/live_grep.gif
- A live outline tree for jumping to function/variable in current file:
  + Demo 1: http://tuhdo.github.io/static/part3/helm-semantic-or-imenu.gif
  + Demo 2: https://cloud.githubusercontent.com/assets/4818719/4102208/cda8f392-311e-11e4-9c83-e68df38ef68e.gif

- Interactively select color and faces: http://tuhdo.github.io/static/part3/helm-color.gif

- Interactive Eshell history, certainly superior to the stock ~C-c C-l~:
  http://tuhdo.github.io/static/part3/helm-eshell-history.gif. I store a large
  amount of shell history, so I want a quick way to narrow down.



XXX Helm is also very useful to look up Elisp variable/function documentation
and for finding stuff in the Info Manuals (e.g. ~helm-info-elisp~ or
~helm-info-emacs~).

XXX Look at helm-dictionary.


#+begin_src emacs-lisp
    ;; Via: http://www.reddit.com/r/emacs/comments/3asbyn/new_and_very_useful_helm_feature_enter_search/
    (setq helm-echo-input-in-header-line t)
    ;; (defun helm-hide-minibuffer-maybe ()
    ;;   (when (with-helm-buffer helm-echo-input-in-header-line)
    ;;     (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
    ;;       (overlay-put ov 'window (selected-window))
    ;;       (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
    ;;                               `(:background ,bg-color :foreground ,bg-color)))
    ;;       (setq-local cursor-type nil))))
    ;;
    ;; (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)
#+end_src

#+begin_src emacs-lisp
    ;; Better version of `occur'.
;;    (global-set-key [remap occur] #'helm-occur) ; helm-regexp.el
    (global-set-key (kbd "C-o")   #'helm-occur) ; helm-regexp.el
    (global-set-key (kbd "C-c o") #'helm-occur) ; helm-regexp.el
#+end_src

#+begin_src emacs-lisp
    (global-set-key (kbd "M-x") #'helm-M-x)
#+end_src

#+begin_src emacs-lisp
    ;; Speedy file opening.
    (global-set-key (kbd "<f3>")
                    #'(lambda ()
                        (interactive)
                        (let ((split-width-threshold (* 2 132)))
                          (helm-for-files))))

    ;; (global-set-key [remap find-file] #'helm-find-files) ; OK. C-x C-f
#+end_src

#+begin_src emacs-lisp
    ;; Buffer list.
    (global-set-key (kbd "C-x b") #'helm-mini) ; OK.
                                        ; = `helm-buffers-list' + recents.

    (global-set-key [remap list-buffers] #'helm-buffers-list) ; OK. C-x C-b
#+end_src

#+begin_src emacs-lisp
    ;; `dabbrev-expand' (M-/) =>`helm-dabbrev'
    ;; (define-key global-map [remap dabbrev-expand] 'helm-dabbrev)
#+end_src

**** Navigating with Structure Views

Popup structure of the current file for quick navigation:

#+begin_src emacs-lisp
    (defun leuven-helm-file-structure (arg)
      "Jump to a place in the buffer using an Index menu.
    For Org mode buffers, show Org headlines.
    For programming mode buffers, show functions, variables, etc."
      (interactive "P")
      (cond ((derived-mode-p 'org-mode) (helm-org-in-buffer-headings))
            ((derived-mode-p 'tex-mode) (helm-imenu))
            (t (helm-semantic-or-imenu arg)))) ; More generic than `helm-imenu'.

    (global-set-key (kbd "<C-f12>") #'leuven-helm-file-structure) ; Awesome.
    ;; (global-set-key (kbd "<f4>") #'leuven-helm-file-structure)
                                        ; And `C-c =' (like in RefTeX)?

    (global-set-key (kbd "C-c o") #'helm-org-agenda-files-headings)
#+end_src

#+begin_src emacs-lisp
    ;; (global-set-key (kbd "M-5") #'helm-etags-select)
#+end_src

#+begin_src emacs-lisp
    (global-set-key (kbd "C-h a") #'helm-apropos) ; OK!
#+end_src

#+begin_src emacs-lisp
    (global-set-key (kbd "C-h i") #'helm-info-emacs) ; OK.
    ;; (global-set-key (kbd "C-h d") #'helm-info-at-point)
    ;; (global-set-key (kbd "C-h 4") #'helm-info-elisp)
#+end_src

#+begin_src emacs-lisp
    ;; (global-set-key (kbd "C-S-h C-c") #'helm-wikipedia-suggest)
#+end_src

#+begin_src emacs-lisp
    (global-set-key (kbd "C-h b") #'helm-descbinds) ; OK.
#+end_src

See helm-flycheck!

#+begin_src emacs-lisp :tangle no
(use-package helm-flycheck
  :ensure t
  :bind (("M-g f"   . my-helm-flycheck)
         ("C-c ! l" . my-helm-flycheck))
  :config
  (defun my-helm-flycheck ()
    "This function makes sure that flycheck has been finished
before running helm-flycheck"
    (interactive)
    (require 'flycheck)
    (if flycheck-mode
        (call-interactively 'helm-flycheck)
      (flycheck-mode)
      (message "[Just turned FlyCheck on, wait a bit for errors to appear...]")
      (run-with-idle-timer 1 nil #'helm-flycheck))))
#+end_src

#+begin_src emacs-lisp
  )                                     ; require 'helm-config ends here.
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load "helm"
#+end_src

#+begin_src emacs-lisp
    ;;! Rebind TAB to do persistent action
    (define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i")   #'helm-execute-persistent-action)
                                        ; Make TAB works in terminal.

    ;; List available actions using C-z.
    ;; (define-key helm-map (kbd "C-z")       #'helm-select-action)
    (define-key helm-map (kbd "<backtab>") #'helm-select-action)
#+end_src

#+begin_src emacs-lisp
    (define-key helm-map (kbd "C-M-n") #'helm-next-source)

    (define-key helm-map (kbd "C-M-p") #'helm-previous-source)

    ;; @ reserved for searching inside buffers! (See C-h m)

    ;; Various functions for Helm (Shell history, etc.).
    (require 'helm-misc)
    ;; For multi-line items in e.g. minibuffer history, match entire items,
    ;; not individual lines within items.

    ;; (try-require 'helm-dictionary)

    ;; Use the *current window* (no popup) to show the candidates.
    (setq helm-full-frame nil)

    ;; Open `helm-buffer' in another window.
    (setq helm-split-window-default-side 'other)

    ;; Default function used for splitting window.
    (setq helm-split-window-preferred-function
          #'(lambda (window)
              (split-window-sensibly)))

    ;; ;; Move to end or beginning of source when reaching top or bottom of
    ;; ;; source.
    ;; (setq helm-move-to-line-cycle-in-source t)

    ;; Candidates separator of `multiline' source (such as
    ;; `helm-show-kill-ring').
    (setq helm-candidate-separator
          "--8<-----------------------separator------------------------>8---")

    ;; Suppress displaying sources which are out of screen at first.
    (setq helm-quick-update t)

    ;; Time that the user has to be idle for, before ALL candidates are
    ;; collected.
    (setq helm-input-idle-delay 0.75)    ; 0.06 OK // 0.70 NOK

    ;; ;; Enable adaptive sorting in all sources.
    ;; (helm-adaptive-mode 1)

    ;; ;; Enable generic Helm completion (for all functions in Emacs that use
    ;; ;; `completing-read' or `read-file-name' and friends).
    ;; (helm-mode 1)
    )
#+end_src

**** Helm find files

~helm-find-files~ is powerful because:

- It has *fuzzy matching* by default (enabled by default, but *disabled* as soon as
  you *add a space* in the pattern).

- It has highlighting on candidates depend on types: directory has a color,
  plain file has a color, executable has a color, shell script has a color.

- Depends on what file type your highlighting candidate is, Helm opens it
  appropriately. For example, if you RET on a directory, Helm opens dired; if
  you RET on a file, Helm opens that file. You can also customize the
  application to open the files. Stock find-file at least can open directory;
  Ido simply can't.

- You can open multiple files with helm-find-files by marking with C-SPC and
  press RET. If you want to everything at current directory, you can use M-a to
  mark all then RET. You can even use wildcard expression like stock find-file

- Helm has a list of actions to apply on your files: checksum file, open file
  externally, switch to eshell, grep, diff...


In helm-find-files, you can alway invoke helm-ff-do-grep with C-s or C-u C-s for
recursive searching. Probably helm-projectile can replace helm-find-files more
if it has this feature? I think you can do this by reusing projectile-grep.

helm-find-files can even find file at point. That is, you don't need to remember
ffap as well. If you write Emacs lisp, move point over the required file and
execute helm-find-files, it will prompt the file location and you simply RET to
enter. All in once nice package.


- ~C-l~ ::
     Delete the last segment of a file name (in the minibuffer).

#+begin_src emacs-lisp
  ;; Disable fuzzy matching.
  (setq helm-ff-fuzzy-matching nil)

  (with-eval-after-load "helm-files"


    ;; Don't show only basename of candidates in `helm-find-files'.
    (setq helm-ff-transformer-show-only-basename nil)

    ;; Search for library in `require' and `declare-function' sexp.
    (setq helm-ff-search-library-in-sexp t)

    ;; ;; Use `recentf-list' instead of `file-name-history' in `helm-find-files'.
    ;; (setq helm-ff-file-name-history-use-recentf t)
    )
#+end_src

#+begin_src emacs-lisp
  ;; This set Helm to open files using designated programs.
  (setq helm-external-programs-associations
        '(("rmvb" . "smplayer")
          ("mp4"  . "smplayer")))
#+end_src

See [[http://stackoverflow.com/questions/14726601/sublime-text-2s-goto-anything-or-instant-search-for-emacs][Sublime Text 2's "Goto Anything" (or instant search) for Emacs?]]
+ https://github.com/xiaohanyu/oh-my-emacs/blob/master/core/ome-completion.org

**** Descbinds

Use the separate Helm Descbinds to get a quick *key bindings* overview.  It will
make your life much easier with million Emacs keys.

#+begin_src emacs-lisp
  ;; A convenient `describe-bindings' with `helm'.
  (with-eval-after-load "helm-descbinds"

    ;; Window splitting style.
    (setq helm-descbinds-window-style 'split-window))
#+end_src

**** Grep (Find in Project)

Launchable from ~current-buffer~ or from ~helm-find-files~.

#+begin_src emacs-lisp
  ;;
  (with-eval-after-load "helm-grep-autoloads"

      (global-set-key (kbd "M-g ,") #'helm-do-grep)

      (global-set-key (kbd "M-g a") #'helm-do-grep-ag) ; Thierry Volpiatto
                                        ; Or `C-c p s s' (Helm-projectile ag?)
      (setq helm-grep-ag-command "rg --color=always --colors 'match:fg:black' --colors 'match:bg:yellow' --smart-case --no-heading --line-number %s %s %s")
      (setq helm-grep-ag-pipe-cmd-switches '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'")) ; #CDCD00

      )
#+end_src

~helm-ag-map~ and ~helm-do-ag-map~ are inherited by ~helm-map~.

| Key           | Action                                                                      |
|---------------+-----------------------------------------------------------------------------|
| C-c o         | Open other window                                                           |
| C-l           | Search in parent directory                                                  |
| C-c C-e       | Switch to edit mode                                                         |
| C-x C-s       | Save ag results to buffer (Ask save buffer name if prefix key is specified) |
| C-c C-f       | Enable helm-follow-mode                                                     |
| C-c > , right | Move to next file                                                           |
| C-c < , left  | Move to previous file                                                       |
| C-c ?         | Show help message                                                           |

If you are using ~ag~, you can place an ~.agignore~ file in the project root with
the *files* (or extensions) you would want to *ignore*.

If you use ~helm-ag~ command, you can specify option like ~-G\.js$~ search_pattern,
or if you use ~helm-do-ag~, you can use ~C-u~ prefix for specifying extension.

#+begin_src emacs-lisp
  ;; the_silver_searcher.
  (when (executable-find "ag")

    ;; The silver searcher with Helm interface.
    (with-eval-after-load "helm-ag-autoloads"

      (global-set-key (kbd "C-c s") #'helm-ag)
      (global-set-key (kbd "M-s s") #'helm-ag)

      ;; Find in Project with Ag (from project root).
      (global-set-key (kbd "C-S-f")   #'helm-do-ag-project-root) ;; Find in project. DOES NOT WORK WELL.
      (global-set-key (kbd "C-M-S-f") #'helm-do-ag-project-root) ;; Find in project. DOES NOT WORK WELL.

      ;; ;; Search with Ag.  Ask for directory first.
      ;; (global-set-key (kbd "C-S-d") #'helm-do-ag)

      ;; Search with Ag this file (like Swoop).
      (global-set-key (kbd "M-g >") #'helm-ag-this-file)

      ;; Search with Ag in current projectile project.
      (global-set-key (kbd "C-S-a") #'helm-projectile-ag)

      (global-set-key (kbd "M-g ,") #'helm-ag-pop-stack)
      ))

  (with-eval-after-load "helm-ag"

    ;; Base command of `ag'.
    (setq helm-ag-base-command (concat helm-ag-base-command " --ignore-case"))

    ;; Command line option of `ag'
    (setq helm-ag-command-option "--all-text")

    ;; Insert thing at point as search pattern.
    (setq helm-ag-insert-at-point 'symbol))
#+end_src

See https://github.com/dingmingxin/dotfiles/blob/master/config_emacs/config/custom-init-helm.el

**** Helm M-x (search for a command)

There's no denying it: it's really difficult to remember all of these various
commands.  Rather than falling back to using the mouse and menu selections,
instead type ~M-x~.

This will bring up a Helm menu, where you can then search for your desired
command.

*************** TODO Get gray for common text of candidates
See http://code.tutsplus.com/tutorials/essential-textmate-shortcuts-tips-and-techniques--net-21168
*************** END

#+begin_note
With ~helm-M-x~, to pass prefix arguments to the command you want to run, you have
to type ~C-u~ *after* typing ~M-x~ and selecting the command -- that is, *before*
pressing ~RET~.
#+end_note

#+begin_src emacs-lisp
  (with-eval-after-load "helm-command"

    ;; Save command even when it fails (on errors).
    (setq helm-M-x-always-save-history t))
#+end_src

**** Helm locate

Use Helm to *quickly navigate between files*, even in the largest projects.

#+begin_note
Locate for *Windows* users: you have to install [[http://www.voidtools.com/download.php][Everything]] with its command line
interface ~es.exe~.
#+end_note

#+begin_src emacs-lisp
  ;; (with-eval-after-load "helm-autoloads"
  ;;   (global-set-key [remap locate] #'helm-locate))

  ;; XXX Problems since Cygwin update (beginning of 2020-02).
  ;; (with-eval-after-load "helm-locate"
  ;;
  ;;   (when (and (or leuven--win32-p leuven--cygwin-p)
  ;;              (executable-find "es"))
  ;;
  ;;     ;; Sort locate results by full path.
  ;;     (setq helm-locate-command "es -s %s %s")))
#+end_src

**** Helm for buffers

As a starting point for all *searches in buffers and files*, use ~helm-buffers-list~
and ~helm-find-files~: you can launch ~helm-multi-occur~ and ~helm-do-grep~ from
there.

You can also use the ~@~ prefix to *search buffer contents*.

#+begin_src emacs-lisp
  (with-eval-after-load "helm-buffers"

    ;; Don't truncate buffer names.
    (setq helm-buffer-max-length nil)

    ;; Never show details in buffer list.
    (setq helm-buffer-details-flag nil)

    ;; String to display at end of truncated buffer names.
    (setq helm-buffers-end-truncated-string "…"))
#+end_src

#+begin_src emacs-lisp
  ;; (with-eval-after-load "helm-adaptive"
  ;;
  ;;   ;; Don't save history information to file.
  ;;   (remove-hook 'kill-emacs-hook 'helm-adaptive-save-history))
#+end_src

**** Helm ring

By pressing ~M-y~, you will see the *clipboard history* (list of all previous
clipboard contents) and can pick the one you want to paste into the text using
arrow keys.  Use ~RET~ to insert it.

#+begin_src emacs-lisp
  ;; Paste from History.
  (global-set-key (kbd "M-y") #'helm-show-kill-ring) ; OK.
#+end_src

#+begin_src emacs-lisp
  ;; (global-set-key (kbd "C-h SPC") #'helm-all-mark-rings)
  (global-set-key (kbd "C-c m") #'helm-all-mark-rings)
#+end_src

~helm-all-mark-rings~ allows you to view the content of the both the *local and
global mark rings* in a friendly interface, so you can always jump back to where
you were.

#+begin_src emacs-lisp
  ;; kill-ring, mark-ring, and register browsers for Helm.
  (with-eval-after-load "helm-ring"

    ;; Max number of lines displayed per candidate in kill-ring browser.
    (setq helm-kill-ring-max-lines-number 20))
#+end_src

#+begin_src emacs-lisp
  ;; (with-eval-after-load "helm-utils"
  ;;   (setq helm-yank-symbol-first t)
#+end_src

**** Helm-ls-git

#+begin_src emacs-lisp
  ;; List Git files.
  (with-eval-after-load "helm-ls-git-autoloads"

    ;; (global-set-key (kbd "C-c C-f") #'helm-ls-git-ls) ; used by Org!
    (global-set-key (kbd "M-+")    #'helm-ls-git-ls)
    ;; (global-set-key (kbd "<S-f3>") #'helm-ls-git-ls)

    ;; Browse files and see status of project with its VCS.
    (global-set-key (kbd "C-x C-d") #'helm-browse-project))
#+end_src

See http://edvorg.com/edvorg/emacs-configs/blob/master/init.d/init-helm.el for
much more configs with Git...

**** Imenu

Imenu is like an outline tree in regular IDE, but Helm makes it interactive, and
fast.  You can ask questions such as "Is there a ~function~ whose name contains
~memory~?".

**** Google

~helm-google-suggest~ is very efficient when you get completions from Google (so
you can type only a few characters to get relevant completions) and then you can
send this completion to various services (e.g. wiki lookup), so you don't have
to start a separate Wikipedia lookup, Youtube lookup, etc. command, because you
can use the same command for any of them.

#+begin_note
You can easily add actions for other sites you usually search for info on.
#+end_note

#+begin_src emacs-lisp
  ;; Emacs Helm Interface for quick Google searches
  (with-eval-after-load "helm-google-autoloads"
    (global-set-key (kbd "C-c h g") #'helm-google)
    (global-set-key (kbd "C-c h s") #'helm-google-suggest))

  ;; (with-eval-after-load "helm-google"
  ;;
  ;;   ;; (when (executable-find "curl")
  ;;   ;;   (setq helm-google-suggest-use-curl-p t))
  ;;   )
#+end_src

**** Helm Projectile

Exploring large projects with Projectile and Helm Projectile:
http://tuhdo.github.io/helm-projectile.html

Helm Projectile replaces many Projectile "core commands", such as
`projectile-find-file`.

A few demos:

- Select and open multiple files,
  http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-files-1.gif :
  Now we can open multiple files at once with `helm-projectile`. It outweighs Ido
  + flx for finding files, since you can only open one file in Ido. Yes, you can
  open one file faster in Helm, but when you need to open two or more files,
  Helm is more suitable for the large.

- Jump to any file depends on context, even if the file path is in a text file,
  http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-files-dwim-1.gif

- Switch between other files with same names but different extensions,
  http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-other-file.gif. Work
  not only for C/C++ but other languages, and is customizable. You don't have to
  configure anything, like adding include paths for the command to
  search. Everything is automatic. Just use it as it is.

- Ediff two selected files from helm-projectile-find-file,
  http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-file-ediff.gif.

- Invoke Etags while in helm-projectile-find-file session; when in Etags
  session, you can switch back later to helm-projectile-find-file,
  http://tuhdo.github.io/static/helm-projectile/helm-projectile-etags.gif.

- You can invoke `helm-do-grep` on any project directory when using
  a `helm-projectile` command.

Key bindings:

- ~C-c p p~ for ~helm-projectile-switch-project~
- ~C-c p f~ for ~helm-projectile-find-file~
- ~C-c p s g~ for ~helm-projectile-grep~
- ~C-c p s a~ for ~helm-projectile-ag~

#+begin_src emacs-lisp
  ;; Disable fuzzy matching for Helm Projectile commands.
  (setq helm-projectile-fuzzy-match nil)

  ;; (global-set-key (kbd "C-;") #'helm-projectile)
#+end_src

**** Lisp completion

#+begin_warning
This (from Thierry Volpiatto) seems good, except that it changes the behavior of
~TAB~ when done in a word.  Instead of indenting, it completes the word at point,
changing the buffer's contents!
#+end_warning

#+begin_src emacs-lisp :tangle no
  ;; Lisp complete or indent.
  (define-key lisp-interaction-mode-map
    [remap indent-for-tab-command] #'helm-lisp-completion-at-point-or-indent)
  (define-key emacs-lisp-mode-map
    [remap indent-for-tab-command] #'helm-lisp-completion-at-point-or-indent)
#+end_src

~M-TAB~?

#+begin_src emacs-lisp
  ;; Lisp complete.
  (define-key lisp-interaction-mode-map
    [remap completion-at-point] #'helm-lisp-completion-at-point)
  (define-key emacs-lisp-mode-map
    [remap completion-at-point] #'helm-lisp-completion-at-point)
#+end_src

**** Helm swoop

# Occur Edit mode applies edits made in ~*Occur*~ buffers to the original buffers.
# It is bound to ~e~ in Occur mode.

Pressing twice C-o goes from Helm Swoop to Helm Multi Swoop...

#+begin_src emacs-lisp
  ;; Efficiently hopping squeezed lines powered by Helm interface
  ;; (= Helm occur + Follow mode!).
  (with-eval-after-load "helm-swoop-autoloads"

    ;; Better version of `(helm-)occur'.
    (global-set-key (kbd "C-o")   #'helm-swoop)
    (global-set-key (kbd "M-s o") #'helm-swoop)
    ;; (global-set-key (kbd "M-i") #'helm-swoop)
    ;; (global-set-key (kbd "M-I") #'helm-swoop-back-to-last-point)

    (global-set-key (kbd "M-s O") #'helm-multi-swoop)
    (global-set-key (kbd "M-s /") #'helm-multi-swoop)
    ;; (global-set-key (kbd "C-c M-i") #'helm-multi-swoop)

    ;; (global-set-key (kbd "C-x M-i") #'helm-multi-swoop-all)

    ;; When doing Isearch, hand the word over to `helm-swoop'.
    (define-key isearch-mode-map (kbd "C-o") #'helm-swoop-from-isearch)
    ;; (define-key isearch-mode-map (kbd "M-i") #'helm-swoop-from-isearch)

    (with-eval-after-load "dired"
      (define-key dired-mode-map (kbd "C-o") #'helm-swoop)
      ;; (define-key dired-mode-map (kbd "M-i") #'helm-swoop)
      ))

  (with-eval-after-load "helm-swoop"

    ;; Move up and down like Isearch.
    (define-key helm-swoop-map (kbd "C-r") #'helm-previous-line)
    (define-key helm-swoop-map (kbd "C-s") #'helm-next-line)
    (define-key helm-multi-swoop-map (kbd "C-r") #'helm-previous-line)
    (define-key helm-multi-swoop-map (kbd "C-s") #'helm-next-line)

    ;; From `helm-swoop' to `helm-multi-swoop-all'.
    (define-key helm-swoop-map (kbd "C-o") #'helm-multi-swoop-all-from-helm-swoop)
    ;; (define-key helm-swoop-map (kbd "M-i") #'helm-multi-swoop-all-from-helm-swoop)

    ;; Don't slightly boost invoke speed in exchange for text color.
    (setq helm-swoop-speed-or-color t)

    ;; Split direction.
    ;; (setq helm-swoop-split-direction 'split-window-horizontally)
    (setq helm-swoop-split-direction 'split-window-sensibly)

    ;; Don't save each buffer you edit when editing is complete.
    (setq helm-multi-swoop-edit-save nil))
#+end_src

*** Image mode

AFAICT you need to eval something like

    (setq image-type-header-regexps '((".*" . imagemagick)))

to be able to resize images in image-mode with imagemagick (for example, from
the "Image" menu).  If resizing works for you when visiting an image file,
I guess your imagemagick support is ok.

*************** TODO auto-image-file-mode in find-file-hook for performance reasons!?

New commands since Emacs 24.4:

- ~v~ in Dired works just as you request: it shows the image,
- ~n~ shows the next image in the same directory (~image-next-file~),
- ~p~ shows the previous image (~image-previous-file~), and
- ~q~ quits.

Get EXIF data with ~image-dired-get-exif-data~.

#+begin_src emacs-lisp
  (leuven--section "Image mode")

  ;; Show image files as images (not as semi-random bits).
  (add-hook 'find-file-hook #'auto-image-file-mode)
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 18 ends here.
#+end_src

