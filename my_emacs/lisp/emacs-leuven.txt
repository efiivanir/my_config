* Compiling and Testing Programs

#+begin_src emacs-lisp
;;* 27 (info "(emacs)Building") Compiling and Testing Programs

(leuven--chapter leuven-load-chapter-27-building "27 Compiling and Testing Programs"
#+end_src

** Running Compilations under Emacs

My build command: ~cd /path/to/Makefile && make -f Makefile~.

You don't need a =Makefile= to perform simple tasks, because ~make~ knows a lot of
built in rules out of the box.  For example, to compile a ~.c~ source file =foo.c=
into a program ~foo~, all you need is say ~make -k foo~, and ~make~ will do it even
without a =Makefile=.

XXX Compiling with ~ant~?

#+begin_src emacs-lisp
;;** 27.1 Running (info "(emacs)Compilation")s under Emacs

  (leuven--section "27.1 Running (emacs)Compilations under Emacs")

  ;; Invoke a compiler with the same command as in the last invocation of
  ;; `compile'.
  (autoload 'recompile "compile"
    "Re-compile the program including the current buffer." t)

  (global-set-key (kbd "<f9>") #'recompile)

  ;; Scroll the `*compilation*' buffer window to follow output as it appears.
  (setq compilation-scroll-output t)

  ;; ;; Number of lines in a compilation window.
  ;; (setq compilation-window-height 8)

  ;; Always kill a running compilation process before starting a new one.
  (setq compilation-always-kill t)
#+end_src

Make the compilation window go away -- if there were no compilation errors:

#+begin_src emacs-lisp
  (defun compile-hide-window-if-successful (cur-buffer msg)
    (if (string-match "exited abnormally" msg)
        ;; There were errors.
        (message "[Compilation errors, press C-x ` to visit]")
      ;; No errors, make compilation window go away in 0.5 sec
      (run-at-time 0.5 nil
                   'delete-windows-on cur-buffer)
      (message "[No compilation errors!]")))

  ;; (add-to-list 'compilation-finish-functions #'compile-hide-window-if-successful)
#+end_src

#+begin_src emacs-lisp
  (defun compile-goto-first-error (cur-buffer msg)
    (with-current-buffer cur-buffer
      (goto-char (point-min))
      (compilation-next-error 1)
      (beep)))

  ;; (add-to-list 'compilation-finish-functions #'compile-goto-first-error)
#+end_src

#+begin_src emacs-lisp
  (defun compile-scroll-eob (cur-buffer msg)
    (let ((win (get-buffer-window cur-buffer))
          (current (selected-window)))
      (when win
        (select-window win)
        (with-current-buffer cur-buffer
          (when (> (line-number-at-pos (point-max)) (window-height))
            (goto-char (point-max))
            (recenter (window-height))))
        (select-window current))))

  (add-to-list 'compilation-finish-functions #'compile-scroll-eob)
#+end_src

#+begin_src emacs-lisp
  (defvar make-clean-command "make clean all"
    "*Command used by the `make-clean' function.")

  (defun make-clean (&optional arg)
    "Run a make clean."
    (interactive "P")
    (require 'compile)                  ; Needed for compile-internal.
    (if arg
        (setq make-clean-command
              (read-string "Command: " make-clean-command)))
    (save-some-buffers (not compilation-ask-about-save) nil)
    (compile-internal make-clean-command "No more errors"))

  (global-set-key (kbd "<S-f9>") #'make-clean)
#+end_src

You're debugging Bash code?  I normally use =mode-compile.el= for this.
Basically, it runs Bash with lots of debug output.

*** Java

Compile within Emacs using ~ant~.

#+begin_src emacs-lisp
  (defvar leuven--ant-command-history nil
    "Ant command history variable")

  (defun leuven-ant (&optional args)
    "Runs ant in the current project. Starting at the directory
     where the file being visited resides, a search is made for
     build.xml recursively. A maven command is made from the first
     directory where the build.xml file is found is then displayed in
     the minibuffer. The command can be edited as needed and then
     executed. Errors are navigate to as in any other compile mode"
    (interactive)
    (let ((fn (buffer-file-name)))
      (let ((dir (file-name-directory fn)))
        (while (and (not (file-exists-p (concat dir "/build.xml")))
                    (not (equal dir (file-truename (concat dir "/..")))))
          (setf dir (file-truename (concat dir "/.."))))
        (if (not (file-exists-p (concat dir "/build.xml")))
            (message "[No build.xml found]")
          (compile (read-from-minibuffer "Command: "
                                         (concat "ant -emacs -f "
                                         dir "/build.xml compile") nil
                                         nil
                                         'leuven--ant-command-history))))))

  (add-hook 'java-mode-hook
            #'(lambda ()
                (local-set-key "<f9>" 'leuven-ant)))
#+end_src

See smart-compile.el!

See jdc.el

#+begin_src emacs-lisp
  ;; Use Java for class files decompiled with Jad.
  (add-to-list 'auto-mode-alist '("\\.jad\\'" . java-mode))
#+end_src

#+begin_src emacs-lisp
  ;; Color identifiers based on their names.
  (with-eval-after-load "color-identifiers-mode-autoloads"
    (add-hook 'java-mode-hook 'color-identifiers-mode))
#+end_src

** Compilation Mode

When Emacs visits the locus of an error message, it momentarily highlights the
relevant source line.  The duration of this highlight is determined by the
variable ~next-error-highlight~.

#+begin_src emacs-lisp
;;** 27.2 (info "(emacs)Compilation Mode")

  (leuven--section "27.2 (emacs)Compilation Mode")

  ;; ;; Automatically jump to the first error during compilation.
  ;; (setq compilation-auto-jump-to-first-error t)

  ;; Display the next compiler error message.
  (global-set-key (kbd "<f10>")   #'next-error) ; C-M-down in IntelliJ IDEA.
                                        ; Also on `M-g n', `M-g M-n' and `C-x `'.

  ;; Display the previous compiler error message.
  (global-set-key (kbd "<S-f10>") #'previous-error) ; C-M-up in IntelliJ IDEA.
                                        ; Also on `M-g p' and `M-g M-p'.

  ;; Display the first compiler error message.
  (global-set-key (kbd "<C-f10>") #'first-error)

  ;; ;; Prefer fringe.
  ;; (setq next-error-highlight 'fringe-arrow)

  ;; Highlight and parse the whole compilation output as soon as it arrives.
  (setq compile-auto-highlight t)
#+end_src

** Searching with Grep under Emacs

Find files matching some regexp, and click on the hyperlinks to the files to
locate your match.

The commands

- ~lgrep~ (local search, with ~grep-template~) and
- ~rgrep~ (*recursive* search, with ~grep-find-template~)

are somehow more user-friendly than the ~M-x grep~ command.

The doc string of ~grep-use-null-device~ which explains that, with its default
value ~auto-detect~, Emacs invokes Grep once with ~/dev/null~ appended (causing the
search to return no results) for the purposes of detecting how to invoke it
thereafter.

#+begin_src emacs-lisp
;;** 27.4 (info "(emacs)Grep Searching") under Emacs

  (leuven--section "27.4 (emacs)Grep Searching under Emacs")

  (with-eval-after-load "grep"

    ;; Run `grep' via `find', with user-friendly interface.
    (global-set-key (kbd "C-c 3") #'rgrep)

    ;; Ignore case distinctions in the default `grep' command.
    (grep-apply-setting 'grep-command "grep -i -H -n -e ")

    ;; Do not append `null-device' (`/dev/null' or `NUL') to `grep' commands.
    (grep-apply-setting 'grep-use-null-device nil)
                                        ; Not necessary if the `grep' program
                                        ; used supports the `-H' option.

    ;; For Windows.
    (when leuven--win32-p
      ;; Default find command for `M-x grep-find'.
      (grep-apply-setting 'grep-find-command '("findstr /sn *" . 13)))
#+end_src

To exclude files from ~lgrep~ and ~rgrep~ results (if you use ~rgrep~ instead of
~grep-find~), you can set up ignored files/dirs in advance:

#+begin_src emacs-lisp
  (with-eval-after-load "grep"
    ;; Files to ignore for MEPLA.
    (add-to-list 'grep-find-ignored-files "archive-contents")

    (add-to-list 'grep-find-ignored-files "*-min.js")
    (add-to-list 'grep-find-ignored-files "*.min.js")

    ;; Files to ignore for ARCHIBUS.
    (add-to-list 'grep-find-ignored-files "ab-core.js")
    (add-to-list 'grep-find-ignored-files "ab-pgnav.js")
    (add-to-list 'grep-find-ignored-files "ab-view.js")
    (add-to-list 'grep-find-ignored-files "app.js")
    ;; (add-to-list 'grep-find-ignored-files "cordova.js")
    (add-to-list 'grep-find-ignored-files "dx.archibus.js")
    (add-to-list 'grep-find-ignored-files "app.css")
    (add-to-list 'grep-find-ignored-files "sencha-touch.css")

    ;; Directories to ignore for ARCHIBUS.
    (add-to-list 'grep-find-ignored-directories "ckeditor")
    (add-to-list 'grep-find-ignored-directories "common/mobile"))
#+end_src

#+begin_note
~helm-ag~ and ~helm-projectile-grep~ also use the settings of the
~grep-find-ignored-*~ variables.
#+end_note

*** Ripgrep

alias rg='rg --color always'

rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --glob "!.git/*" --color "always"

rg -S --no-heading

helm-ag-base-command "rg --no-heading"

Option ~--sort-files~ sorts results by file path, but disables all parallelism and
runs search in a single thread.

#+begin_src emacs-lisp
    (when (executable-find "rgXXX")        ; ripgrep.

      ;; Default grep command for `M-x grep'.
      ;; (grep-apply-setting 'grep-command "ag --nogroup --numbers ")

      ;; Default command to run for `M-x lgrep'.
      (grep-apply-setting 'grep-template "rg --no-heading -H -uu -g <F> <R> <D>")

      ;; Default find command for `M-x grep-find'.
      ;; (grep-apply-setting 'grep-find-command '("ag --noheading --column " . 25))

      ;; Default command to run for `M-x rgrep'.
      (grep-apply-setting 'grep-find-template
                          "find <D> <X> -type f <F> -exec rg <C> --no-heading -H <R> /dev/null {} +"))
                                        ; `<D>' = path.
                                        ; `<X>' for the find options to restrict
                                        ;       directory list.
                                        ; `<F>' = glob.
                                        ; ------------------------------------
                                        ; `<C>' for the place to put `-i' if the
                                        ;       search is case-insensitive.
                                        ; `<R>' = pattern.
#+end_src

See https://stackoverflow.com/questions/45526670/rgrep-in-emacs-to-use-ripgrep.

Some problems with ripgrep:
- no match highlighting,
- error parsing regex when string is, for example, ~Handler().update~ or ~myFunc(~.

find . -name "*.log" -type f -print0 | xargs -I _ sh -c 'iconv -f utf16 -t utf8 _ | grep runPMGeneration'

*** The Silver Searcher

Ag, the silver searcher (in Cygwin!):
- https://github.com/howardabrams/dot-files/blob/master/emacs.org
- https://www.reddit.com/r/emacs/comments/3fr4ro/how_do_you_grep/

Ag output options:

- ~--[no]color~ ::
     Print *color* codes in results.

- ~--column~ ::
     Print *column numbers* in results.

- ~--[no]heading~ ::

- ~--[no]group~ ::
     Same as ~--[no]break --[no]heading~.

- ~--line-numbers~ (or ~--numbers~) ::
     Print *line numbers* even for streams.

Ag search options:

- ~--depth~ ::
     Search up to *~NUM~ directories deep* (Default: ~25~).

- ~--ignore-case~ ::
     Match *case insensitively*.

- ~--all-text~ ::
     Search *all text files* (doesn't include hidden files).

#+begin_src shell :tangle no
ag %s -l --nocolor --hidden -g ""
#+end_src

#+begin_src emacs-lisp
    ;; Prefer rg > ag.
    (when (and (executable-find "agXXX") ; XXX Need to fix base dir and file extensions!!!
               (not (executable-find "rg")))

      ;; Default grep command for `M-x grep'.
      ;; (grep-apply-setting 'grep-command "ag --nogroup --numbers ")

      ;; Default command to run for `M-x lgrep'.
      ;; (grep-apply-setting 'grep-template "ag --depth 0 <R> <F>")

      ;; Default find command for `M-x grep-find'.
      ;; (grep-apply-setting 'grep-find-command '("ag --noheading --column " . 25))

      ;; Default command to run for `M-x rgrep' (`C-c 3').
      (grep-apply-setting 'grep-find-template
                          "ag --color --nogroup --line-numbers <R> ."))
                                        ; `<D>' for the base directory.
                                        ; `<X>' for the find options to restrict
                                        ;       directory list.
                                        ; `<F>' for the find options to limit
                                        ;       the files matched.
                                        ; ------------------------------------
                                        ; `<C>' for the place to put `-i' if the
                                        ;       search is case-insensitive.
                                        ; `<R>' for the regular expression to
                                        ;       search for.
#+end_src

#+begin_src emacs-lisp :tangle no
      ;; Default command to run for `M-x rgrep' (`C-c 3').
      (grep-apply-setting 'grep-find-template
                          "find <D> <X> -type f <F> -print0 | \"xargs\" -0 grep <C> -nH -e <R>")
#+end_src

#+begin_src emacs-lisp
    ;; This is how compilers number the first column, usually 1 or 0.
    ;; (setq-default grep-first-column 1)

    ;; Use `find -print0' and `xargs -0'.
    (setq grep-find-use-xargs 'gnu))    ; with-eval-after-load "grep" ends here.
#+end_src

#+begin_src emacs-lisp
  ;; Run `grep' via `find', with user-friendly interface.
  (global-set-key (kbd "C-c 3") #'rgrep)
#+end_src

** Finding Syntax Errors On The Fly

Flycheck (aka "Flymake done right") can perform static code analysis *on-the-fly*,
and *highlight warnings and errors* in the code immediately as you are editing it,
if you made a mistake.

To *list all errors in the current buffer*, you can popup an error list with
~C-c ! l~ (~M-x flycheck-list-errors~).

(See https://github.com/steelbrain/linter in Atom.)

In the error list window the following keybindings are available:

- ~n~ ::
     Move to the *next error*.

- ~p~ ::
     Move to the *previous error*.

- ~q~ ::
     Hide the error list window.

- ~RET~ ::
     Jump to the location of the error at point.

- ~g~ ::
     Refresh the error list, by triggering a new syntax check in the associated
     buffer.

- ~S~ ::
     Sort the error list by the column at point. Press repeatedly to inverse the
     sorting order.

#+begin_note
~C-c ! v~ (or ~M-x flycheck-verify-setup~) is a diagnostic tool which displays
diagnostic information about the active checker in your current buffer.  Useful
if you have ~$PATH~ issues or are missing the checker entirely on your system.
#+end_note

XXX Display errors in the right fringe

#+begin_tip
~FlyC-~, in the mode line, either means that there is *no checker* or that it got
interrupted. See ~flycheck-mode-line-status-text~ for more information.
#+end_tip

Navigate:
- Next Highlighted Error (F2)
- Previous Highlighted Error (Shift+F2).

[[http://www.flycheck.org/en/latest/user/error-reports.html][!FlyC: See errors in buffers]]

#+begin_src emacs-lisp
;;** 27.5 (info "(emacs)Flymake")

  (leuven--section "27.5 (emacs)Flymake")

  ;; Modern on-the-fly syntax checking.
  (with-eval-after-load "flycheck-autoloads"

    ;; Enable Flycheck mode in all programming modes. XXX Should not in Java?
    (add-hook 'prog-mode-hook  #'flycheck-mode)

    (add-hook 'LaTeX-mode-hook #'flycheck-mode)

    (global-set-key (kbd "M-g l") #'flycheck-list-errors))

  (with-eval-after-load "flycheck"

    ;; Delay in seconds before displaying errors at point.
    (setq flycheck-display-errors-delay 0.3)

    (setq flycheck-indication-mode 'left-fringe) ; See init.el.
    ;; ;; Indicate errors and warnings via icons in the right fringe.
    (setq flycheck-indication-mode 'right-fringe)

    ;; Remove newline checks, since they would trigger an immediate check when
    ;; we want the `flycheck-idle-change-delay' to be in effect while editing.
    (setq flycheck-check-syntax-automatically
          '(save
            idle-change
            ;; new-line
            mode-enabled))

    ;; Each buffer get its local `flycheck-idle-change-delay' because of the
    ;; buffer-sensitive adjustment above.
    (make-variable-buffer-local 'flycheck-idle-change-delay)

    (defun leuven--adjust-flycheck-automatic-syntax-eagerness ()
      "Adjust how often we check for errors based on if there are any.

This lets us fix any errors as quickly as possible, but in
a clean buffer we're an order of magnitude laxer about checking."
      (setq flycheck-idle-change-delay
            (if (assq 'error (flycheck-count-errors flycheck-current-errors))
                ; only check for REAL errors (original source: Magnar Sveen)
                1
              20)))

    ;; Functions to run after each syntax check.
    (add-hook 'flycheck-after-syntax-check-hook
              #'leuven--adjust-flycheck-automatic-syntax-eagerness)
#+end_src

A summary of the inspection results for the current file is shown in the colored
mode line on bottom.  Make it blue!

#+begin_src emacs-lisp
    ;; Change mode line color with Flycheck status.
    (with-eval-after-load "flycheck-color-mode-line"
      (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode)))
#+end_src

#+begin_src emacs-lisp :tangle no
  ;; Provide an error display function to show errors in a tooltip.
  (with-eval-after-load 'flycheck
    (flycheck-pos-tip-mode)) ; XXX Check if defined.
#+end_src

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-S-e") #'elint-current-buffer)

  (with-eval-after-load "elint"
    (add-to-list 'elint-standard-variables 'current-prefix-arg)
    (add-to-list 'elint-standard-variables 'command-line-args-left)
    (add-to-list 'elint-standard-variables 'buffer-file-coding-system)
    (add-to-list 'elint-standard-variables 'emacs-major-version)
    (add-to-list 'elint-standard-variables 'window-system))
#+end_src

** Running Debuggers Under Emacs

#+begin_src emacs-lisp
;;** 27.6 Running (info "(emacs)Debuggers") Under Emacs

  (leuven--section "27.6 Running (emacs)Debuggers Under Emacs")

  (with-eval-after-load "gdb-mi"

    ;; Enable Gdb-Many-Windows mode.
    (setq gdb-many-windows t))          ; The only important parameter for GDB.
#+end_src

#+begin_src emacs-lisp :tangle no
  (define-key jde-mode-map [f8]   'jdibug-step-over)
  (define-key jde-mode-map [M-f8] 'jdibug-step-into)
  (define-key jde-mode-map [f7]   'jdibug-step-out)
  (define-key jde-mode-map [M-f7] 'jdibug-resume)
#+end_src

Highlight the current GUD line in GDB/Emacs:

#+begin_src emacs-lisp
  (defvar gud-overlay
    (let* ((ov (make-overlay (point-min) (point-min))))
      (overlay-put ov 'face '(:background "#F6FECD"))
                                        ; Color for Leuven theme
                                        ; (highlight-yellow).
      ov)
    "Overlay variable for GUD highlighting.")

  (defadvice gud-display-line (after my-gud-highlight act)
    "Highlight current line."
    (let* ((ov gud-overlay)
           (bf (gud-find-file true-file)))
      (save-excursion
        (set-buffer bf)
        (move-overlay ov (line-beginning-position) (line-end-position)
                      (current-buffer)))))
#+end_src

** Debugging Lisp programs

Emacs has the basic debugger/stack trace, but it also has the Edebug facility,
which is very powerful, for the more complex situation.

With that source-level debugger for Emacs Lisp, you can:
- step through evaluation, stopping before and after each expression,
- set conditional or unconditional breakpoints.

#+begin_src emacs-lisp
;;** Debugging Lisp programs

  ;; Source-level debugger for Emacs Lisp.
  (with-eval-after-load "edebug"

    ;; ;; Display a trace of function entry and exit.
    ;; (setq edebug-trace t)
#+end_src

While ~edebug~'ging, use ~T~ to view a trace buffer (~*edebug-trace*~).  Emacs will
quickly execute the rest of your code, printing out the arguments and return
values for each expression it evaluates.

#+begin_src emacs-lisp
    (defadvice edebug-overlay-arrow (around leuven-highlight-line activate)
      "Highlight line currently being Edebug'ged."
      (require 'hl-line)
      (hl-line-mode)
      ad-do-it)

    (defun leuven-edebug-quit ()
      "Stop Edebug'ging and remove highlighting."
      (interactive)
      (hl-line-mode -1)
      (top-level))

    (define-key edebug-mode-map [remap top-level] #'leuven-edebug-quit))
#+end_src

** Executing Lisp Expressions

Just as in C, C++, Java, Perl, Python, etc, Lisp code is kept in files.  All
the normal editing operations are performed on files.  In this respect, hacking
in Lisp is like hacking in any other language that you are used to.  What's
different is that what you are hacking is a running Lisp program.  When you
edit a function definition or add a new one, you compile it into a running
program.  There is no compile, link, run, debug cycle as you know it from C or
Java.

Ponder that for a minute.

When you fix a bug in a C function, you have to recompile, relink, and reload
your program before you can test the fix.  You don't do that in Lisp.  You make
the fix and then go straight to testing it.  This process can be even faster
than fixing a bug in a scripting language like Perl.

** Libraries of Lisp Code for Emacs

#+begin_src emacs-lisp
;;** 27.8 (info "(emacs)Lisp Libraries") for Emacs

  (leuven--section "27.8 (emacs)Lisp Libraries")

  ;; Remove *.elc when save.
  (defun remove-elc-on-save ()
    "If you're saving an elisp file, likely the .elc is no longer valid."
    (make-local-variable 'after-save-hook)
    (add-hook 'after-save-hook
              #'(lambda ()
                  (if (file-exists-p (concat buffer-file-name "c"))
                      (delete-file (concat buffer-file-name "c"))))))

  (add-hook 'emacs-lisp-mode-hook #'remove-elc-on-save)

  ;; Force load of `.el' files when they are newer than the `.elc' files.
  (setq load-prefer-newer t)            ; From Emacs 24.4.
#+end_src

** Evaluating Emacs Lisp Expressions

- ~C-x C-e~ ::
     Evaluate the Emacs Lisp expression before point, and print the value in
     the echo area (~eval-last-sexp~).

- ~C-M-x~ (in Emacs Lisp mode) ::
     Evaluate the defun containing or after point, and print the value in the
     echo area (~eval-defun~).

To (attempt to) cleanly reevaluate a buffer of Emacs Lisp code, use
~nuke-and-eval~.

#+begin_src emacs-lisp
;;** 27.9 (info "(emacs)Lisp Eval") Expressions

  (leuven--section "27.9 (emacs)Lisp Eval Expressions")

  ;; Enable the use of the command `eval-expression' without confirmation.
  (put 'eval-expression 'disabled nil)

  ;; Maximum depth of lists to print in the result of the evaluation commands
  ;; before abbreviating them.
  (setq eval-expression-print-level nil) ; No limit.

  ;; Maximum length of lists to print in the result of the evaluation commands
  ;; before abbreviating them.
  (setq eval-expression-print-length nil) ; No limit.
#+end_src

#+begin_src emacs-lisp
  ;; ;; Limit serving to catch infinite recursions for you before they
  ;; ;; cause actual stack overflow in C, which would be fatal for Emacs.
  ;; (setq max-lisp-eval-depth 600)        ; 1000?
#+end_src

#+begin_src emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (let ((value (eval (preceding-sexp))))
      (kill-sexp -1)
      (insert (format "%S" value))))

  (global-set-key (kbd "C-c e") #'eval-and-replace)
#+end_src

For on-the-fly evaluation/substitution of Emacs Lisp code, see
https://github.com/Fuco1/litable.

See demo of it: http://www.youtube.com/watch?v=TMoPuv-xXMM.

#+begin_src emacs-lisp
  ;; Dynamic evaluation replacement with Emacs.
  (with-eval-after-load "litable-autoloads"

    (add-hook 'lisp-interaction-mode-hook #'litable-mode))
#+end_src

** Lisp Interaction Buffers (~*scratch*~)

#+begin_src emacs-lisp
;;** 27.10 (info "(emacs)Lisp Interaction") Buffers

  (leuven--section "27.10 (emacs)Lisp Interaction Buffers")

  ;; Don't display the "Welcome to GNU Emacs" buffer on startup.
  (setq inhibit-startup-screen t)

  ;; Don't insert instructions in the `*scratch*' buffer at startup.
  (setq initial-scratch-message nil)
#+end_src

Don't use any specific mode for the initial buffer.  That ensure that no Lisp
or Org specific stuff gets loaded at each startup time.

#+begin_src emacs-lisp
  ;; Major mode command symbol to use for the initial `*scratch*' buffer.
  (setq initial-major-mode 'fundamental-mode)
#+end_src

*That code must be used in the ~.emacs~ file (or libraries loaded from it).*
Otherwise, ~*scratch*~ will already have been created, in the default major
mode.

To evaluate a non-interactive command, simply use ~IELM~.

** Switching to a Buffer in a Window

Emacs's windows are locked in an eternal fight with their user as they fight
over screen estate and what buffer is allowed to be shown where. The concept of
strongly dedicated window is alien to most Emacs users as it's fairly byzantine
to figure out. This variable, which is customizable, will let you decide how
buffer switching works when a window and its buffer are fundamentally
entwined. I recommend you set it to ~prompt~ if you are curious about its effects,
as that will prompt you to decide what to do next -- no doubt annoying in the
long run, but useful for figuring out how Emacs's windowing mechanics work.

#+begin_src emacs-lisp
  (setq switch-to-buffer-in-dedicated-window 'prompt)
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 27 ends here.
#+end_src

* Maintaining Programs

#+begin_src emacs-lisp
;;* 28 (info "(emacs)Maintaining") Programs

(leuven--chapter leuven-load-chapter-28-maintaining "28 Maintaining Programs"
#+end_src

** Version Control

A unified Emacs UI for interacting with Git, SVN and other VCS (Version Control
Systems) in a generic way -- a real timesaver.

- ~C-x v d~ ::
     Open Dired buffer in VC-mode.

- ~C-x v v~ ::
     Take appropriate "next" action (add, commit).

- ~C-x v r~ (or ~M-!~ ?) ::
     Switch Git branches.

- ~C-x v +~ ::
     vc-update.

#+begin_src emacs-lisp
;;** 28.1 (info "(emacs)Version Control")

  (leuven--section "28.1 (emacs)Version Control")

  ;; Always follow symlinks to files under source-control.  Don't ask.
  (setq vc-follow-symlinks t)

  ;; (setq vc-allow-async-revert t)

  ;; (setq vc-git-diff-switches '("-w" "-U3")) ;; XXX What about mnemonicprefix=true?

;; ;; When opening a file that is a symbolic link, don't ask whether I
;; ;; want to follow the link. Just do it
;; (setq find-file-visit-truename t)
#+end_src

*** Version Control and the Mode Line

"Unmodified-according-to-VC" buffers use ~-~ as a separator in their VC
indicator, and modified buffers have ~:~ (e.g., ~CVS-1.2~ vs. ~CVS:1.2~).  The
tooltip over the VC indicator also says more explicitly.

*************** Lisp expression in mode-line-format
The Lisp expressions supported in ~mode-line-format~ are those documented in the
manual, and nothing else.  In particular, the ~:eval~ part must appear
explicitly, and any symbol stands for its value (which is not eval'ed).  IOW, a
full-blown Lisp evaluation there is not implemented...
*************** END

*** Features of the Log Entry Buffer

- ~C-c C-d~ ::
     Show the diff we are about to commit.

- ~D~ (~vc-git-previous-revision~) ::
     Get the previous revision.

Using Emacs VC, you only have to write the ChangeLog, then use ~C-c C-a~ to insert
it into the commit buffer. So there is no need to "write the same thing twice".

#+begin_src emacs-lisp
;;*** 28.1.4 (info "(emacs)Log Buffer")

  (defun leuven--vc-log-mode-setup ()
    (when (leuven--executable-ispell-program-name-p)
      (setq ispell-local-dictionary "american")
      (flyspell-mode)))

  (add-hook 'vc-log-mode-hook #'leuven--vc-log-mode-setup)
#+end_src

#+begin_src emacs-lisp
  (autoload 'vc-git-root "vc-git")
  (with-eval-after-load "vc-git"

    ;; Major mode for editing git commit messages.
    (idle-require 'git-commit))

  (with-eval-after-load "git-commit"

    ;; Turn on on-the-fly spell-checking.
    (add-hook 'git-commit-setup-hook #'flyspell-mode)

    ;; Turn off save-place.
    (add-hook 'git-commit-setup-hook
              #'(lambda ()
                  (toggle-save-place 0))))
#+end_src

See http://whattheemacsd.com/setup-magit.el-01.html.

Or use Tig?  See http://blogs.atlassian.com/2013/05/git-tig/.

*** Examining And Comparing Old Revisions

VC can show you the *history of changes* to a *particular line of code*:

1. Run the command ~vc-annotate~ (with either ~M-x vc-annotate~ or ~C-x v g~).
2. Each line will show up with its *revision*, like a normal ~blame~, and a *heatmap*.

*************** TODO Customize vc-annotate colors to be cold after 90 days
*************** END

3. Pressing ~a~ (~vc-annotate-revision-previous-to-line~) will navigate to the
   revision before the revision at the line you're on.

#+begin_src emacs-lisp
;;*** 28.1.6 (info "(emacs)Old Revisions")

  (leuven--section "28.1.6 Examining And Comparing Old Revisions")

  ;; Switches for diff under VC.
  (setq vc-diff-switches diff-switches)
#+end_src

*** VC Change Log

#+begin_src emacs-lisp
;;*** 28.1.7 (info "(emacs)VC Change Log")

  (leuven--section "28.1.7 VC Change Log")
#+end_src

- ~C-x v l~ ::
     Display the change history for the current *file* (~vc-print-log~).

- ~C-x v L~ ::
     Open the *log buffer* for the current *repository* (List the change log for the
     current VC controlled tree in a window).

     When in it:
     - ~C-m~ to read the commit message,
     - ~d~ to see the corresponding diff.

We have at least two pairs of commands:

- ~C-x v l~ vs ~C-x v L~ /and/
- ~C-x v =~ vs ~C-x v D~,

of which one operates on the current *file* vs \\
the other on the *repository* as a whole (entire project).

- ~C-x v l~ to view the file's history.
- ~n~ and ~p~ to move between commits.
- ~f~ to visit the file as of the commit at point.

The command ~vc-region-history~ shows the *log + diff of the active region*.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x v H") #'vc-region-history)
#+end_src

~git-timemachine~ makes the process of *navigating between different versions* of
a file almost completely seamless.

You call ~M-x git-timemachine RET~ from a buffer visiting a tracked file, then you
can use the following keys to navigate historic versions of the file:

- ~p~ ::
     Visit *previous* historic version.

- ~n~ ::
     Visit *next* historic version.

- ~w~ ::
     Copy the abbreviated hash of the current historic version.

- ~W~ ::
     Copy the full hash of the current historic version.

- ~q~ ::
     Exit the time machine.

#+begin_src emacs-lisp
  ;; Walk through Git revisions of a file.
  (with-eval-after-load "git-timemachine-autoloads"

    ;; Number of chars from the full SHA1 hash to use for abbreviation.
    (setq git-timemachine-abbreviation-length 7)

    (global-set-key (kbd "C-x v t") #'git-timemachine))
#+end_src

#+begin_src emacs-lisp
  ;; Pop up last commit information of current line.
  (with-eval-after-load "git-messenger-autoloads"

    (global-set-key (kbd "C-x v p") #'git-messenger:popup-message) ; `C-h g'.

    ;; Pop up commit ID and author name too.
    (setq git-messenger:show-detail t))
#+end_src

*** VC Directory Mode

#+begin_src emacs-lisp
;;*** 28.1.9 (info "(emacs)VC Directory Mode")

  (leuven--section "28.1.9 VC Directory Mode")

  (defun leuven-vc-jump ()
    "Jump to VC status buffer."
    (interactive)
    (let* ((fname (buffer-file-name))
           (dname (if fname
                      (if (file-directory-p fname)
                          fname
                        (file-name-directory fname))
                    default-directory)))
      (message "[VC status for directory: %s]" dname)
      (vc-dir dname)))

  ;; VC status without asking for a directory.
  (global-set-key (kbd "<C-f9>") #'leuven-vc-jump)

  (add-hook 'vc-dir-mode-hook
            #'(lambda ()
                ;; Hide up-to-date and unregistered files.
                (define-key vc-dir-mode-map
                  (kbd "x") #'leuven-vc-dir-hide-up-to-date-and-unregistered)
                (define-key vc-dir-mode-map
                  (kbd "E") #'vc-ediff)
                (define-key vc-dir-mode-map
                  (kbd "#") #'vc-ediff-ignore-whitespace)
                                        ; ediff-windows-wordwise?
              ))

  (defun leuven-vc-dir-hide-up-to-date-and-unregistered ()
    (interactive)
    (vc-dir-hide-up-to-date)
    (vc-dir-hide-unregistered))

  (defun vc-dir-hide-unregistered ()
    "Hide unregistered items from display."
    (interactive)
    (let ((crt (ewoc-nth vc-ewoc -1))
          (first (ewoc-nth vc-ewoc 0)))
      ;; Go over from the last item to the first and remove the unregistered
      ;; files and directories with no child files.
      (while (not (eq crt first))
        (let* ((data (ewoc-data crt))
               (dir (vc-dir-fileinfo->directory data))
               (next (ewoc-next vc-ewoc crt))
               (prev (ewoc-prev vc-ewoc crt))
               ;; ewoc-delete does not work without this...
               (inhibit-read-only t))
          (when (or
                 ;; Remove directories with no child files.
                 (and dir
                      (or
                       ;; Nothing follows this directory.
                       (not next)
                       ;; Next item is a directory.
                       (vc-dir-fileinfo->directory (ewoc-data next))))
                 ;; Remove files in the unregistered state.
                 (eq (vc-dir-fileinfo->state data) 'unregistered))
            (ewoc-delete vc-ewoc crt))
          (setq crt prev)))))

  (defun vc-ediff-ignore-whitespace (historic &optional not-urgent)
    "Ignore regions that differ in white space & line breaks only."
    (interactive (list current-prefix-arg t))
    (require 'ediff)
    (let ((ediff-ignore-similar-regions t))
      (call-interactively 'vc-ediff)))  ; XXX does not work yet!
#+end_src

*** Branches

- C-x v P (M-x vc-push) ::
     Basic *push* support.

*** Customizing VC

#+begin_src emacs-lisp
;;*** 28.1.13 (info "(emacs)Customizing VC")

  (leuven--section "28.1.13 Customizing VC")

  ;; Files covered by VC get backups (as with other files).
  (setq vc-make-backup-files t)

  ;; http://www.emacswiki.org/emacs/VcTopDirectory
  ;; For Git.
  (defadvice vc-dir-prepare-status-buffer
             (before leuven-vcs-goto-top-directory activate compile)
    (let* ((backend (ad-get-arg 2))
           (vcs-dir (ad-get-arg 1))
           (vcs-top-dir (vc-call-backend backend 'responsible-p vcs-dir)))
      (when (stringp vcs-top-dir)
        (ad-set-arg 1 vcs-top-dir))))

  (defun leuven--ediff-revision (file rev1 &optional rev2)
    "Run Ediff by comparing 'master' against the 'current'."
    (require 'ediff)
    (find-file file)
    (if (and (buffer-modified-p)
             (y-or-n-p (format "Buffer %s is modified.  Save buffer? "
                               (buffer-name))))
        (save-buffer (current-buffer)))
    (ediff-load-version-control)
    (funcall
     (intern (format "ediff-%S-internal" ediff-version-control-package))
     rev1 rev2 nil))

  (defun leuven-vc-diff (&optional arg)
    (interactive "P")
    (call-interactively
     (cond (arg
            #'(lambda ()
                (interactive)
                (vc-diff nil)))
           (t
            #'(lambda ()
                (interactive)
                (leuven--ediff-revision (buffer-file-name)
                                        (read-string "revision? "
                                                     "HEAD" nil "HEAD")
                                        ""))))))

  (define-key vc-prefix-map (kbd "=") #'leuven-vc-diff)
#+end_src

Today I learned that it is also interactive. I can cycle through revisions using
p and n, open the file at a specified revision with f, view the log with l, and
show a diff with d or changeset diff with D. (Unfortunately, the diff is ugly
and not in color.)


The best command in vc-annotate is "a": Reruns annotate from the revision _prior_
to the revision that last changed the current line, so you can dig deeper into
that line's raison d'etre, skipping uninteresting commits like whitespace
changes.

#+begin_src emacs-lisp
(setq vc-annotate-display-mode nil)

;; http://www.onerussian.com/Linux/.files/dot_emacs
(setq vc-annotate-background "seashell")
(setq vc-annotate-very-old-color "black")

(setq vc-annotate-color-map
  '((  1.0 . "#FFCCCC") ; red
    (  7.0 . "#FFE4CC") ; orange
    ( 30.0 . "#DEFFCC") ; green
    ( 90.0 . "#CCE4FF") ; blue
    (360.0 . "#C9C9C9"))) ; white
#+end_src

*************** TODO Customize `vc-annotate-background' (and future `vc-annotate-foreground')
*************** END

** Change Logs

#+begin_src emacs-lisp
;;** 28.2 (info "(emacs)Change Log")

  (leuven--section "28.2 (emacs)Change Logs")

  (with-eval-after-load "add-log"

    ;; Don't make a new entry, when the last entry was made by you and on the
    ;; same date.
    (setq add-log-always-start-new-record nil)

    ;; Add the file's version number to the change log entry.
    (setq change-log-version-info-enabled t)

    ;; Remove 'Invalid function' in Emacs 27
    ;; (add-hook 'change-log-mode-hook
    ;;           (add-to-list
    ;;            'change-log-font-lock-keywords
    ;;            '("^[0-9-]+:? +\\|^\\(Sun\\|Mon\\|Tue\\|Wed\\|Thu\\|Fri\\|Sat\\) [A-z][a-z][a-z] [0-9:+ ]+"
    ;;              (0 'change-log-date-face)
    ;;              ("\\([^<(]+?\\)[   ]*[(<]\\([[:alnum:]_.+-]+@[[:alnum:]_.-]+\\)[>)]" nil nil
    ;;               (1 'change-log-name)
    ;;               (2 'change-log-email)))))
  )
#+end_src

** Tags Tables (navigating code)

Using tags tables is the most generic approach to setup *code navigation*.  A
"tag" signifies a language object for which an index entry is available.

#+begin_note
There are many situations when you cannot or might not want to use ~tags~.  You
would like to use [[id:ea687cd8-fff0-461f-999e-c9fbc84b5901][Imenu]] because:

- Imenu is meaningful in non-programming modes and for non-visiting buffers.

- Virtually all modes already define Imenu, so it works out of the box
  everywhere, even if you read a language in which you will never write.

- And finally, Imenu operates on what you work on -- open files -- you don't get
  thousands of symbols from ~etags~ to deal with.

Using ~helm-imenu-in-all-buffers~ offers a much better, more uniform and more
consistent experience than anything else.
#+end_note

Always run ~make TAGS~ right after you build some project.

Once you've built a ~TAGS~ file (~ctags~ / ~etags~), you can find all commands that
match a regexp.

Support for tags has been in Emacs for a long time: any installation of Emacs
should comes with the ~etags~ program, which supports many different languages.

Comparison of tools:

- etags (Emacs-style TAGS file) ::
     Ada, Asm, *C*, Objective C, *C++*, C#, Cobol, Erlang, Forth, Fortran, HTML,
     *Java*, *Lisp*, Lua, Makefile, Pascal, Perl, *PHP*, Postscript, Prolog, *Python*,
     Scheme, TeX, TeXinfo, and YACC.

     On Windows, Emacs comes with ~etags~ and a similar executable file called
     ~ctags~.  In the Emacs distribution, =etags.exe= = =ctags.exe= in the =bin=
     directory.

- Exuberant Ctags ::
     Ant, Asm, Asp, Awk, Basic, BETA, *C*, *C++*, C#, Cobol, DosBatch, Eiffel,
     Erlang, Flex, Fortran, HTML, *Java*, JavaScript, *Lisp*, Lua, Makefile,
     MatLab, OCaml, Pascal, Perl, *PHP*, *Python*, REXX, *Ruby*, Scheme, Sh, SLang,
     SML, SQL, Tcl, TeX, Vera, Verilog, VHDL, Vim, and YACC.

     You should download *Exuberant Ctags* from http://ctags.sourceforge.net/ or
     from Cygwin.  Only *Exuberant* =ctags.exe= recognizes ~-e~ option (/etags mode/,
     which will create a tag file for use with the Emacs editor).

     Exuberant Ctags can be extended to look for other things via regular
     expression.  It is a wonderful thing!

     For example, I can now look for tags in my shell code to by running:

     #+begin_src shell :tangle no
     etags --langdef=shell --regex-shell='/function [_[:alnum:]]+/[_[:alnum:]]+/' --language-force=shell
     #+end_src

- Cscope ::
     C, but flexible enough to support C++ and Java, and to be used as a
     generalized "grep database".

- ebrowse ::
     For C++, you will be better off with ebrowse, a program that also comes
     with Emacs.  It understands C++ much better than etags does, and provides
     similar commands (so you don't lose anything).  Check out the Ebrowse
     manual, which is part of the Emacs distribution, for details.

- GNU Idutils ::

- GNU Global (gtags) ::
     *C*, *C++*, Yacc, *Java*, and *PHP4*.

     Global is a lot smarter about finding tags tables, and is fairly fast to
     update.

*Emacs TAGS* and *Exuberant Ctags* don't do fancy stuff, e.g. keeping an index of
function references.  They record only positions where a function (or variable
etc.) is *defined*.

Recording positions where a function is *called* (finding all *symbol references*)
is the kind of thing external tools such as *GNU Global*, *GNU Idutils* and *Cscope*
can do for you, if you're working with a language that they support.  *Grep*
would be the fallback method.

Please also see [[http://hub.opensolaris.org/bin/view/Project+opengrok/][Comparison with Similar Tools]].

Once you have a good tagging system in place, many tools become enabled for your
language, such as:

- tag decoration mode (like drawing lines over the top of function tags),
- stickyfunc mode (which shows the current function in the header line),
- [[id:5032bcdb-ac6b-4101-a0ce-28192fb7e247][Emacs Code Browser]], and
- tag jumping.

#+begin_src emacs-lisp
;;** 28.3 (info "(emacs)Tags")

  (leuven--section "28.3 (emacs)Tags Tables")
#+end_src

*** Creating Tags Tables

First of all, you must build a ~TAGS~ file (which keeps the symbols from your
project, by scanning all the source and header files with the ~etags~ command).

For example, you can have a ~TAGS~ Makefile target to do this for you:

#+begin_src makefile :tangle no
TAGS:
        rm -f TAGS
        find $$(pwd) \( -name \*.el \
                     -o -name \*.[chCH] \
                     \) -print | /usr/bin/ctags -e -
#+end_src

You can create a =TAGS= file by using ~M-x compile RET tags RET~.  Every time
you changes your source file, you need to regenerate the tag file.

Alternatively,

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "etags"

    ;; Tags enhancements.
    (try-require 'sure-tags))
#+end_src

will make sure that ~TAGS~ file exists (and builds it if it doesn't), allowing
you to

- first rebuild the ~TAGS~ file or
- specify a new one

when the search fails.

*** Finding a Tag (go to function definition)

#+begin_note
New package Xref replaces Etags's front-end and UI.

The new package Xref provides a generic framework and new commands to
find and move to definitions of functions, macros, data structures
etc., as well as go back to the location where you were before moving
to a definition.  It supersedes and obsoletes many Etags commands.
#+end_note

You can *go to* the first *definition* of a tag (matching your regexp) -- *according*
*to TAGS file* -- by using ~M-x xref-find-definitions~ (bound to ~M-.~).  The default
tag is the identifier under the cursor.

If ~M-.~ brings up the wrong method, you can type ~C-u M-.~ to continue searching
for the *next definition* with the same name.

Use ~M-,~ (~M-x xref-pop-marker-stack~) to *jump back* to where you last invoked ~M-.~.

XXX See http://marmalade-repo.org/packages/jump-dls to jump to the source of the
symbol at point using a number of possible methods, such as semantic, tags, etc.

*** Select from multiple TAGS files

You can search for *occurrences* of tags that match you regexp on all files in
the TAGS table, by using ~M-x tags-search RET~.

#+begin_src emacs-lisp
  ;; (with-eval-after-load "etags"
  ;;
  ;;   ;; Select from multiple tags.
  ;;   (try-require 'etags-select))

  (with-eval-after-load "etags-select"

    ;; Do a `find-tag-at-point', and display all exact matches.
    (global-set-key (kbd "M-?") #'etags-select-find-tag-at-point))
#+end_src

However, the default Emacs' etag feature is not quite good. You should use etags
provided by Helm.  Instead of activating ~etags-select-goto-tag~, try
~helm-etags-select~.  If the project is big, it take some time to load tag file.
But when it is done, the next search will be very fast.

See http://truongtx.me/2014/04/20/emacs-javascript-completion-and-refactoring/.

*** Find Emacs Lisp symbol definition

Find the definition of the Emacs Lisp symbol near point:

- ~C-x F~ ::
     Find *function*.

- ~C-x K~ ::
     Find function *bound to key* sequence.

- ~C-x V~ ::
     Find *variable*.

- ~M-x find-face-definition~ ::
     Find *face*.

Use ~C-x 4~ for displaying in another window, and ~C-x 5~ for displaying in
another frame.

#+begin_src emacs-lisp
  ;; Find the definition of the Emacs Lisp function or variable near point.
  (find-function-setup-keys)
#+end_src

Go to source code for symbol at point:

#+begin_src emacs-lisp
  (with-eval-after-load "lisp-mode"

    (defun leuven-goto-lisp-symbol-at-point ()
      "Go to the definition of the Emacs Lisp symbol at point."
      (interactive)
      (require 'thingatpt)              ; XXX use xref-find-definitions instead?
      (let ((sym (symbol-at-point)))    ; or (find-tag-default) or (current-word)?
        (funcall (pcase sym
                   ((pred facep)           'find-face)
                   ((pred symbol-function) 'find-function)
                   (_                      'find-variable))
                 sym)))

    (define-key emacs-lisp-mode-map (kbd "M-.") #'leuven-goto-lisp-symbol-at-point))
#+end_src

*** dump-jump (go to definition)

With this package, you can jump to a definition (of the symbol at point) for
multiple languages without any setup (e.g. *no =TAGS= file is needed anymore*).

Dumb Jump uses
- ripgrep ~rg~ (the best ~grep~ alternative),
- The Silver Searcher ~ag~, or
- falls back to ~grep~
to find potential definitions of a function or variable under point.

It uses a set of regular expressions based on the file extension, or ~major-mode~,
of the current buffer.

See https://github.com/jacktasia/dumb-jump.

Keyboard shortcuts:

| Command                             | Leuven | Sublime Text | Visual Studio |
|-------------------------------------+--------+--------------+---------------|
| Go to definition                    | C-M-g  | F12          | F12           |
| Back (can be called multiple times) |        |              |               |
| Open definition to the side         |        |              | C-k F12       |
|-------------------------------------+--------+--------------+---------------|
| Quick look                          | C-M-y  |              |               |

#+begin_src emacs-lisp
;; XXX IntelliJ IDEA:
;; C-f1
;; Quick Definition View: C-S-i
;; Quick Documentation View: C-q
  (with-eval-after-load "dumb-jump-autoloads"

    ;; ;; Use Helm as selector when there are multiple choices.
    ;; (setq dumb-jump-selector 'helm)

    ;; Prefer to use `rg' over `ag'.
    (setq dumb-jump-prefer-searcher 'rg)

    ;; Number of seconds a grep/find command can take before being warned to use
    ;; ag and config.
    (setq dumb-jump-max-find-time 5)

    (global-set-key (kbd "M-g j") #'dumb-jump-go)
    (global-set-key (kbd "<f12>") #'dumb-jump-go)
                                        ; Conflict when GDB'ing Emacs under
                                        ; Win32.
    ;; (global-set-key (kbd "C-M-g") #'dumb-jump-go)
    ;; (global-set-key (kbd "C-c S") #'dumb-jump-go)

    (global-set-key (kbd "M-g o") #'dumb-jump-go-other-window)
    ;; (global-set-key (kbd "C-M-o") #'dumb-jump-go-other-window)

    (global-set-key (kbd "M-g x") #'dumb-jump-go-prefer-external)
    (global-set-key (kbd "M-g z") #'dumb-jump-go-prefer-external-other-window)

    (global-set-key (kbd "M-g P") #'dumb-jump-back)

    ;; (define-key prog-mode-map (kbd "C-M-q") nil)

;; XXX ‘dumb-jump-quick-look’ is an obsolete command (as of 2020-06-26);
;; XXX ‘dumb-jump-quick-look’ has been obsoleted by the xref interface.

    (global-set-key (kbd "M-g y") #'dumb-jump-quick-look)
    (global-set-key (kbd "C-M-y") #'dumb-jump-quick-look)

    (dumb-jump-mode)
)
#+end_src

#+begin_note
~rg~ is faster, but its results aren't deterministic and it doesn't support
*multiline* search or full *PCRE*, that's where ~ag~ is useful.
#+end_note

Need to debug it?

- If ~dumb-jump-go~ fails, search the same string with ~helm-projectile-ag~.
- If ~helm-projectile-ag~ fails, see ~helm-ag--last-command~ and make it from
  command line.
- If it fails, try it with plain ~ag~ without all the flags.
- If it fails, try it with alternative tool like ~grep~ or ~ack~.

(from https://kozikow.com/2016/05/21/nice-new-emacs-package-dumb-jump-el/)

** Emacs Development Environment

*** Collection of Emacs Development Environment Tools

#+begin_src emacs-lisp
;;** 28.4 (info "(emacs)EDE")

  (leuven--section "28.4 Emacs Development Environment")
#+end_src

CEDET (integrated into Emacs 23.2) brings improvements over a plain TAGS file.
It provides:

- [[http://www.gnu.org/software/emacs/manual/semantic.html][Semantic]] ::
     A *parser* and code analyzer which provides *smart completion*
     ("Intellisense").

- EDE ::
     A *project management* system which can *generate Makefiles* to compile your
     code for you.

     #+begin_tip
     Projectile is another Emacs library providing easy project management and
     navigation.  The concept of a project is pretty basic -- just a folder
     containing special file.  Git repos are considered projects by default.  If
     you want to mark a folder manually as a project just create an empty
     =.projectile= file in it.
     #+end_tip

- SRecode ::
     A template / *code generation* system which can convert tags from semantic
     back into code.

- COGRE (COnnected GRaph Editor) ::
     A *UML diagram editor* which can generate code from a class diagram that you
     draw in Emacs.

See [[http://cedet.sourceforge.net/languagesupport.shtml][supported languages]].

The commands to display *symbol references* are:

- ~C-c , g~ ::
     ~semantic-symref-symbol~.

- ~C-c , G~ ::
     ~semantic-symref~ (current tag).

#+begin_src emacs-lisp
  (unless (string< emacs-version "23.2")
    ;; ;; Enable global EDE (project management) features.
    ;; (global-ede-mode 1)

    (setq semantic-default-submodes
          '(
            ;; Turn Semantic DB mode on (Semantic parsers store the results of
            ;; parsing source code in a database file, which can be saved for
            ;; future Emacs sessions).
            global-semanticdb-minor-mode

            ;; The idle scheduler will automatically reparse buffers in idle
            ;; time.
            global-semantic-idle-scheduler-mode ; [minimum-features]

            ;; Display a summary of the symbol at point in the echo area
            ;; (~ ElDoc).
            global-semantic-idle-summary-mode ; [code-helpers]

            ;; Display a tooltip with a list of possible completions near the
            ;; cursor.
            global-semantic-idle-completions-mode ; [gaudy-code-helpers]

            ;; Turn Semantic MRU Bookmarks on (keep track of the Most
            ;; Recently Used tags).
            global-semantic-mru-bookmark-mode

            ;; Enable Semantic-Stickyfunc mode (display a header line that shows
            ;; the declaration line of the function or tag).
            global-semantic-stickyfunc-mode ; [gaudy-code-helpers]

            ;; Enable Semantic-Highlight-Func mode.
            global-semantic-highlight-func-mode ; [excessive-code-helpers]

            ;; Turn on all active decorations.  Show Method Separators.
            global-semantic-decoration-mode ; [gaudy-code-helpers]
            ))

    ;; XXX If prog-mode, then Semantic will be launched after Emacs init, as
    ;; the scratch buffer is in Emacs Lisp...
    (add-hook 'java-mode-hook #'semantic-mode)
                                        ; Enable parser features (Semantic mode)
                                        ; and install a `Development' menu on
                                        ; the menu-bar.

    ;; ;; Smart completion, and display of information for tags & classes.
    ;; (require 'semantic/ia)
    ;;
    ;; (require 'semantic/db)

    (with-eval-after-load "semantic"

      (defun leuven--semantic ()
        ;; Automatically complete whatever symbol you are typing.
        (local-set-key
          (kbd "C-c ?") #'semantic-ia-complete-symbol) ; Better binding: `M-/'?

        ;; Jump to the definition of the symbol under cursor.
        (local-set-key
          (kbd "C-c j") #'semantic-ia-fast-jump) ; Where a symbol is declared.

        ;; Show the documentation of the symbol under cursor.
        (local-set-key
          (kbd "C-c q") #'semantic-ia-show-doc) ; Show javadoc of the right method.

        ;; Show a summary about the symbol under cursor.
        (local-set-key
          (kbd "C-c s") #'semantic-ia-show-summary)


        ;; Show possible public member functions or data members (when at `.'
        ;; or `->' after an object name).
        (local-set-key
          (kbd "C-c >") #'semantic-complete-analyze-inline)

        ;; ;; Toggle between the implementation and a prototype of symbol under
        ;; ;; cursor.
        ;; (local-set-key
        ;;   (kbd "C-c p") #'semantic-analyze-proto-impl-toggle) ; vs Projectile.

        ;; Visit the header file under cursor.
        (local-set-key
          (kbd "C-c =") #'semantic-decoration-include-visit)


        ;; Unfold the block under cursor.
        (local-set-key
          (kbd "C-c +") #'semantic-tag-folding-show-block)

        ;; Fold the block under cursor.
        (local-set-key
          (kbd "C-c -") #'semantic-tag-folding-fold-block)

        ;; C-c C-c is not a prefix key!
        ;; ;; Unfold all.
        ;; (local-set-key
        ;;   (kbd "C-c C-c +") #'semantic-tag-folding-show-all)
        ;;
        ;; ;; Fold all.
        ;; (local-set-key
        ;;   (kbd "C-c C-c -") #'semantic-tag-folding-fold-all)
        )

      (add-hook 'prog-mode-hook #'leuven--semantic)

      (defun leuven--c-mode-semantic ()
        "Completion on `.' or `->'."
        (local-set-key (kbd ".") #'semantic-complete-self-insert)
        (local-set-key (kbd ">") #'semantic-complete-self-insert)
        (local-set-key (kbd "C-c C-r") #'semantic-symref))

      (add-hook 'c-mode-common-hook #'leuven--c-mode-semantic))
                                        ; Note that this will apply to all
                                        ; cc-modes, e.g. c-mode, c++-mode,
                                        ; php-mode, csharp-mode, awk-mode.

    ;; Hooks, specific for Semantic.
    (defun leuven--semantic-imenu ()
      (imenu-add-to-menubar "TAGS"))

    (add-hook 'semantic-init-hook #'leuven--semantic-imenu)

    )
#+end_src

*** Advanced Code Browsing
:PROPERTIES:
:ID:       5032bcdb-ac6b-4101-a0ce-28192fb7e247
:END:

Some people use CEDET in combination with [[http://www.xemacs.org/Documentation/packages/html/ecb_2.html][ECB (the Emacs Code Browser)]], which
provides views of directories and files.

Keyboard navigation:

- ~C-c . g d~ ::
     Go to directories.

- ~C-c . g s~ ::
     Go to sources.

- ~C-c . g m~ ::
     Go to methods.

- ~C-c . g h~ ::
     Go to history.

- ~C-c . g 1~ ::
     Go to edit buffer.

#+begin_src emacs-lisp :tangle no
  ;; Emacs Code Browser.
  (custom-set-variables '(ecb-options-version "2.40"))
  (try-require 'ecb-autoloads)
  (with-eval-after-load "ecb-autoloads"

    ;; Trick for starting ECB 2.40 (with CEDET merged in Emacs since 23.2).
    (require 'semantic/analyze)
    (provide 'semantic-analyze)
    (provide 'semantic-ctxt)
    (provide 'semanticdb)
    (provide 'semanticdb-find)
    (provide 'semanticdb-mode)
    (provide 'semantic-load)

    (setq stack-trace-on-error t)

    ;; Don't show tip of the day at start time of ECB.
    (setq ecb-tip-of-the-day nil)

    ;; ;; Toggle activation of ECB (between `ecb-activate' and `ecb-deactivate').
    ;; (global-set-key (kbd "C-c e") #'ecb-minor-mode)
  )
#+end_src

If you've installed CEDET and ECB, EmacsAssist is worth trying out:
http://www.mail-archive.com/gnu-emacs-sources@gnu.org/msg00292.html

It uses CEDET to provide a handy symbols browser for the current file, that
narrows down the list as you type substrings.  Tastes differ, but I for one
really like this.

#+begin_src emacs-lisp :tangle no
  (try-require 'eassist)
  (with-eval-after-load "eassist"

    (defun leuven--c-mode-eassist ()
      (local-set-key (kbd "C-c t") #'eassist-switch-h-cpp)
      (local-set-key (kbd "C-x t") #'eassist-switch-h-cpp)
      ;; (local-set-key (kbd "C-c e") #'eassist-list-methods)
      )

    (add-hook 'c-mode-common-hook #'leuven--c-mode-eassist))
                                        ; Note that this will apply to all
                                        ; cc-modes, e.g. c-mode, c++-mode,
                                        ; php-mode, csharp-mode, awk-mode.
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 28 ends here.
#+end_src

*** Projectile

Projectile's features.

- C-c p p ::
     *Switch* between *projects* you have worked on.

**** Navigating project files

- C-c p f ::
     Prompt you for a *file* in project to *jump to*.

- C-c p d ::
     Prompt you for a *directory* in project to *jump to*.

- C-c p e ::
     Prompt you for a *recently visited file* in the project to *jump to*.

- C-c p b ::
     Prompt you for a project *buffer* to *jump to*.

- C-c p l ::
     *Jump to* a *file in a directory*.

**** Running grep and occur

- C-c p s g (or C-c p g in Emacs-Leuven) ::
     Run *~grep~* on the files in the project.

- C-c p s s ::
     Run *~ag~* on the files in the project. [Helm-Projectile]

- C-c p o ::
     Run *~multi-occur~* on all project's buffers currently open.

**** X

- C-c p R ::
     *Regenerate* project *~etags~ or ~gtags~* (requires ~ggtags~).

**** Running tests and compilation commands

- C-c p P ::
     Run a *test* command (~make test~) for the current project.

- C-c p c ::
     Run a *compilation* command (~make~) for the current project.

- C-c p u ::
     Run a *run* command for the current project.

**** Switching between tests and source files

- C-c p t ::
     *Toggle between* an *implementation* file *and* its *test* file.

- C-c p T ::
     *Jump to* a *test file* in project.

**** Switching between controllers and views

- C-c p a ::
     *Switch between files* with *same name* but *different extensions* (e.g. =.h= <->
     =.c= / =.cpp=).

# - C-c p g ::
#      *Jump to file at point* in project.

**** Running VC

- C-c p v ::
     Open version control for the current project.

**** Opening Dired

- C-c p D ::
     Open *Dired* at the root of the project.

**** Running a shell command

- C-c p ! ::
     Run a shell command in the project root.

**** X

- C-c p k ::
     *Kill all* project *buffers*.

- C-c p r ::
     *Replace* literal string in project.

#+begin_src emacs-lisp
  (with-eval-after-load "projectile-autoloads"
    (idle-require 'projectile)

    (with-eval-after-load "projectile"
      ;; Turn on projectile mode by default for all file types
      (projectile-mode)
      ;; (projectile-global-mode) ??

      ;; Add keymap prefix.
      (define-key projectile-mode-map (kbd "C-c p")   #'projectile-command-map)

      (define-key projectile-mode-map (kbd "C-c p g") #'projectile-grep)

      (setq projectile-completion-system 'helm)
      (setq projectile-completion-system 'helm-comp-read)

      ;; Turn on Helm key bindings for projectile.
      (when (locate-library "helm-projectile")
        (helm-projectile-on))

      ;; ;; For large projects.
      ;; (setq helm-projectile-sources-list
      ;;       '(helm-source-projectile-projects
      ;;         helm-source-projectile-files-list))
  ))

  (with-eval-after-load "projectile"

    ;; Indexing method.
    ;; (setq projectile-indexing-method 'native)

    ;; Enable caching of the project's files unconditionally.
    (setq projectile-enable-caching t)

    ;; Action invoked AFTER SWITCHING PROJECTS with `C-c p p'.
    (setq projectile-switch-project-action 'helm-projectile-find-file)
                                        ;; 'projectile-dired
                                        ;; 'projectile-find-file ; Default.
                                        ;; 'projectile-find-file-in-known-projects
                                        ;; 'projectile-find-file-dwim
                                        ;; 'projectile-find-dir

    ;; Don't echo messages that are not errors.
    (setq projectile-verbose nil)

    ;; Always ignore .class files.
    (add-to-list 'projectile-globally-ignored-file-suffixes ".class")

    ;; Ignore remote projects.
    (setq projectile-ignored-project-function 'file-remote-p)

    ;; Mode line lighter prefix for Projectile.
    (setq projectile-mode-line-prefix " P")
    ;; (setq projectile-mode-line-function
    ;;       '(lambda ()
    ;;          (if (and (projectile-project-p)
    ;;                   (not (file-remote-p default-directory)))
    ;;              (format " P[%s]" (projectile-project-name))
    ;;            "")))

    ;; Command to use with ‘projectile-run-project’.
    (setq projectile-project-run-cmd "mintty /bin/bash -l -e '../../start.sh'") ; ARCHIBUS.

    ;; For ARCHIBUS.
    (add-to-list 'projectile-other-file-alist '("axvw" "js")) ; Switch from AXVW -> JS.
    (add-to-list 'projectile-other-file-alist '("js" "axvw")) ; Switch from JS -> AXVW.

    (defun leuven-find-file-archibus-log ()
      (interactive)
      (when-let ((root (projectile-project-root))
                 (logfile "WEB-INF/config/archibus.log"))
          (if (file-exists-p (expand-file-name logfile root))
              (find-file (expand-file-name logfile root))
            (user-error "You're not in an ARCHIBUS project"))))
    (define-key projectile-mode-map (kbd "C-c p A") #'leuven-find-file-archibus-log)
  )
#+end_src

*** Refactoring

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "emr-autoloads"
    (add-hook 'prog-mode-hook #'emr-initialize)
    (define-key prog-mode-map (kbd "M-RET") #'emr-show-refactor-menu))
#+end_src

* Abbrevs (Snippets, Auto Replacements, or live Code Templates)

An "abbrev" is a *word* which has been defined (in a fixed list) to "expand"
into a specified *expansion*.

It allows you to write frequently used text more quickly.

#+begin_src emacs-lisp
;;* 29 (info "(emacs)Abbrevs")

(leuven--chapter leuven-load-chapter-29-abbrevs "29 Abbrevs"

  ;; See (info "(autotype)") as well
#+end_src

** Controlling Abbrev Expansion

Inspired by [[http://macromates.com/][TextMate]].  In fact, many editors support *snippets* (/quick texts/):
Eclipse, Notepad++, etc.

*************** TODO Add rv for "REVIEW[who] text" https://www.jetbrains.com/help/idea/using-live-templates-in-todo-comments.html
*************** END

For complex templates, I use ~YASnippet~.  For example, new file templates (where
it's Lisp evaluation is handy), class and function templates with docblocks,
etc. I use it to reduce the repetitious parts of programming, and let me focus
on getting things done.

~YASnippet~ does support mirror fields and transformations.  It also does support
multiple snippets with same name.  It will also expand snippets containing
non-word-constituent characters, which ~abbrev~ can't.  So I can't have ~@p~ expand
to ~@param~ with ~abbrev~, but I can with ~YASnippet~.

XXX Look at https://github.com/vderyagin/dotemacs/blob/master/conf/yasnippet-configuration.el

#+begin_example
# -*- mode: snippet -*-
# name: file.name
# key: hello
# --
Hello,$0 ${1:this} is a ${2:snippet}.
#+end_example

Predefined YASnippet variables:
- ~$0~ indicates the position of the cursor after the template is expanded.
- ~`yas-selected-text`~ is used in *surround templates* and stands for the code
  fragment to be wrapped.

#+begin_src emacs-lisp
;;** 29.3 Controlling (info "(emacs)Expanding Abbrevs")

  (leuven--section "29.3 Controlling Expanding Abbrevs")

  ;; Yet Another Snippet extension for Emacs
  (with-eval-after-load "yasnippet-autoloads"
    (idle-require 'yasnippet))

  (with-eval-after-load "yasnippet"
#+end_src

*** Organizing snippets

Where are the snippets?  ~yas-snippet-dirs~ is assumed to contain *directories of
modes* with snippets:

- ~yas-installed-snippets-dir~ (the bundled snippets), and
- *your own snippets* in the directory =~/.emacs.d/snippets=.

Load additional snippets.

#+begin_src emacs-lisp
    ;; Add root directories that store the snippets.
    (let ((leuven-snippets              ; Additional YASnippets.
           (concat leuven--directory "../.emacs.d/snippets")))

      (when (file-directory-p leuven-snippets)
        (add-to-list 'yas-snippet-dirs leuven-snippets)))
                                        ; The first element (inserted last) is
                                        ; always the user-created snippets
                                        ; directory.

    ;; Use Snippet mode for files with a `yasnippet' extension.
    (add-to-list 'auto-mode-alist '("\\.yasnippet\\'" . snippet-mode))
#+end_src

*** Installation

**** Use YASnippet as a global minor mode

#+begin_src emacs-lisp
    ;; Enable YASnippet in all buffers.
    (yas-global-mode 1)
#+end_src

#+begin_tip
Use ~yas-global-mode~ *after* you set yas-snippet-dirs. Otherwise you have to use
~yas-reload-all~.
#+end_tip

**** Use ~yas-minor-mode~ on a per-buffer basis

#+begin_src emacs-lisp :tangle no
    ;; Enable YASnippet in programming modes only.
    (add-hook 'prog-mode-hook #'yas-minor-mode)
#+end_src

#+begin_src emacs-lisp
    (with-eval-after-load "diminish-autoloads"
      (diminish 'yas-minor-mode " y"))

    ;; Load the snippet tables.
    (yas-reload-all)

    ;; Wrap around region.
    (setq yas-wrap-around-region t)
#+end_src

*** Expanding snippets

- ~C-c & C-s~ ::
     Insert snippet at point.

Insert *code templates* (/snippets/) by pressing ~TAB~.

#+begin_src emacs-lisp :tangle no
    ;; ;; Bind `yas-expand' to SPC.
    ;; (define-key yas-minor-mode-map (kbd "<tab>") nil)
    ;; (define-key yas-minor-mode-map (kbd "TAB") nil)
    ;; (define-key yas-minor-mode-map (kbd "SPC") #'yas-expand)
#+end_src

#+begin_src emacs-lisp
    ;; Don't expand when you are typing in a string or comment.
    (add-hook 'prog-mode-hook
              #'(lambda ()
                  (setq yas-buffer-local-condition
                        '(if (nth 8 (syntax-ppss))
                                        ; Non-nil if in a string or comment.
                             '(require-snippet-condition . force-in-comment)
                           t))))

    ;; UI for selecting snippet when there are multiple candidates.
    (setq yas-prompt-functions '(yas-dropdown-prompt))
#+end_src

YASnippet allows navigating through the data input fields, where you can specify
your own data.  Use the ~TAB~ key to go forward and the ~Shift+TAB~ keys to go back.

*** Writing snippets

See http://cupfullofcode.com/snippet-expansion-with-yasnippet/.

- ~C-c & C-n~ (~yas-new-snippet~) ::
     Creates a new snippet, pre-filled out with the basic structure.

- ~C-c & C-v~ ::
    ~yas-visit-snippet-file~.

*** YASnippet menu

After editing your snippets:

- ~M-x yas-recompile-all~ to compile all snippets,

- ~M-x yas-reload-all~ to reload them all.

#+begin_src emacs-lisp
    (global-set-key (kbd "C-c & C-r") #'yas-reload-all)
#+end_src

Automatically reload snippets after saving.

#+begin_src emacs-lisp
    ;; Automatically reload snippets after saving.
    (defun recompile-and-reload-all-snippets ()
      (interactive)
      (when (derived-mode-p 'snippet-mode)
        (yas-recompile-all)
        (yas-reload-all)
        (message "[Reloaded all snippets]")))

    (add-hook 'after-save-hook #'recompile-and-reload-all-snippets)
#+end_src

Display all available snippets with ~M-x yas-describe-tables~ (or ~C-c & C-l~ in
Emacs-Leuven):

#+begin_src emacs-lisp
    (global-set-key (kbd "C-c & C-l") #'yas-describe-tables)
#+end_src

See http://stackoverflow.com/questions/10155181/display-all-snippets-of-yasnippet.

#+begin_src emacs-lisp
    (defvar leuven-contextual-menu-map
      (let ((map (make-sparse-keymap "Contextual menu")))
        (define-key map [help-for-help] (cons "Help" 'help-for-help))
        (define-key map [seperator-two] '(menu-item "--"))
        map)
      "Keymap for the contextual menu.")

    (defun leuven-popup-contextual-menu (event &optional prefix)
      "Popup a contextual menu."
      (interactive "@e \nP")
        (define-key leuven-contextual-menu-map [lawlist-major-mode-menu]
          `(menu-item ,(symbol-name major-mode)
            ,(mouse-menu-major-mode-map) :visible t))
        (define-key leuven-contextual-menu-map (vector major-mode)
          `(menu-item ,(concat "Insert " (symbol-name major-mode) " snippet")
            ,(gethash major-mode yas--menu-table)
              :visible (yas--show-menu-p ',major-mode)))
        (popup-menu leuven-contextual-menu-map event prefix))

    (global-set-key [mouse-3] #'leuven-popup-contextual-menu)
#+end_src

*** Frequently Asked Questions

**** Why is there an extra newline?

#+begin_src emacs-lisp
    (add-hook 'snippet-mode-hook
              #'(lambda ()
                  (setq require-final-newline nil)))
#+end_src

**** Why doesn't TAB expand a snippet?

1. Check the mode line to see if there's ~yas~. If not, then try
   ~M-x yas-minor-mode~ to manually turn on the minor mode and try to expand the
   snippet again.

   If it works, then, you can add the following code to your =.emacs= before
   loading YASnippet:

   #+begin_example
   (add-hook 'the-major-mode-hook #'yas-minor-mode-on)
   #+end_example

   where ~the-major-mode~ is the major mode in which ~yas-minor-mode~ isn't enabled
   by default.

   You can also use the command ~M-x yas-global-mode~ to turn on YASnippet
   automatically for all major modes.

2. If ~yas-minor-mode~ is on but the snippet still not expanded, then try to see
   what command is bound to the ~TAB~ key: press ~C-h k~ and then press ~TAB~. Emacs
   will show you the result.

   You'll see a buffer prompted by Emacs saying that ~TAB~ runs the command "...".
   Alternatively, you might see ~TAB~ runs the command "...". Note the
   difference between ~TAB~ and ~TAB~ where the latter has priority.

   If you see ~TAB~ bound to a command other than ~yas-expand~ (e.g. in org-mode),
   you can try a work around. See
   https://github.com/capitaomorte/yasnippet/blob/master/doc/faq.org.

**** yas-key-syntaxes

~yas-key-syntaxes~ is the variable that allows you control the behavior "don't
expand words finishing with the snippet key", even if:

- the default syntax table for the major mode you are working on says that "C-s"
  (for example) is two separate words, and

- assuming you don't want to fix the major mode's behavior.

Find it at http://capitaomorte.github.io/yasnippet/snippet-reference.html#yas-key-syntaxes

#+begin_src emacs-lisp
    ;; ;; Make the "yas-minor-mode"'s expansion behavior to take input word
    ;; ;; including hyphen.
    ;; (setq yas-key-syntaxes '("w_" "w_." "^ "))
                                        ; [default:
                                        ; '("w" "w_" "w_." "w_.()"
                                        ;   yas-try-key-from-whitespace)]

    )
#+end_src

*** Reference

#+begin_src emacs-lisp
    ;; Log level for `yas--message'.
    (setq yas-verbosity 2)              ; Warning.
#+end_src

*** Quickly create disposable YASnippets

#+begin_src emacs-lisp
  (with-eval-after-load "auto-yasnippet-autoloads"
      ;; (global-set-key (kbd "H-w") #'aya-create)
      (global-set-key (kbd "H-y") #'aya-open-line))
#+end_src

** Dynamic Abbrev Expansion
:PROPERTIES:
:ID:       0fa23e4a-e42c-4317-834c-d2ef7c9d741c
:END:

"Dynamic abbrevs" allow the meanings of abbreviations (expansions) to be
*determined automatically from the contents of the buffer*.  It is completely
independent of Abbrev mode.

- ~M-/~ runs the command ~dabbrev-expand~ by default.  Expand previous word
  "dynamically".  *Expands to the most recent, preceding word* for which this is
  a prefix.

- ~C-M-/~ runs the command ~dabbrev-completion~.  Completion on current word.  Like
  ~M-/~ but finds all expansions in the current buffer and *presents suggestions
  for completion*.

See [[id:4b262301-5370-40c6-8da6-019215634e20][completion for symbol names]].

#+begin_src emacs-lisp
;;** 29.7 (info "(emacs)Dabbrev Customization")

  (leuven--section "29.7 Dabbrev Customization")

  ;; (with-eval-after-load "dabbrev"
  ;;
  ;;   ;; Preserve case when expanding the abbreviation.
  ;;   (setq dabbrev-case-replace nil))
#+end_src

** Code Completion

However, there are 3 amazing "intelligent guessing completion frameworks" in
Emacs:

- "Hippie" expansion,
- Auto-Complete and
- Company.

Hippe-expand is great (can complete whole code blocks for you, making it possible
to e.g. cycle through all if-tests in your projects).

But Auto-Complete and Company mode are even better. They'll give you a nice
IntelliSense style menu, will "learn" as you use it, and allows you to define
a file with the completions you'd like to be available in the various languages.

I prefer Company over Auto-Complete but YMMV.

*** "Hippie" expansion (Autotype)

Typically, *we bind ~hippie-expand~ to ~M-/~*, with ~dabbrev-expand~ (the standard
binding of ~M-/~) providing one of the expansion possibilities.

#+begin_src emacs-lisp
  ;; Expand text trying various ways to find its expansion.
  (global-set-key (kbd "M-/") #'hippie-expand) ; Built-in.
#+end_src

#+begin_tip
Would we want to bind ~hippie-expand~ on TAB, we should have to write a ~smart-tab~
command which would look if the major mode is Org and then act differently...
#+end_tip

# (use-package hippie
#   :load-path "vendor"
#   :bind (("C-." . hippie-expand-no-case-fold)
#          ("C-," . hippie-expand-lines))
#   :config
#   (require 'hippie))

#+begin_src emacs-lisp
  (with-eval-after-load "hippie-exp"

    ;; List of expansion functions tried (in order) by `hippie-expand'
    ;; (completion strategy).
    (setq hippie-expand-try-functions-list
          '(;; Searching the current buffer.
            try-expand-dabbrev

            ;; Emacs Lisp symbol, as many characters as unique.
            try-complete-lisp-symbol-partially

            ;; Emacs Lisp symbol.
            try-complete-lisp-symbol

            ;; Searching visible window parts.
            try-expand-dabbrev-visible

            ;; ;; Searching (almost) all other buffers (see
            ;; ;; `hippie-expand-ignore-buffers').
            ;; try-expand-dabbrev-all-buffers

            ;; File name, as many characters as unique.
            try-complete-file-name-partially

            ;; File name.
            try-complete-file-name))
#+end_src

See https://github.com/dgutov/dot-emacs/blob/master/site-lisp/hippie.el for
a local var version of ~hippie-expand-try-functions-list~ for Emacs Lisp.

Configure Hippie-expand to also expand YASnippets (on the key used by
~hippie-expand~, then).

#+begin_src emacs-lisp
    ;; Integrate YASnippet with `hippie-expand'.
    (with-eval-after-load "yasnippet"

      (add-to-list 'hippie-expand-try-functions-list
                   'yas-hippie-try-expand)))
                                        ; Makes more sense when placed at the
                                        ; top of the list.
#+end_src

*** Auto-Complete ("IntelliSensy" completion when writing code)

Auto-Complete shows completions as you type, so you can fill in long words by
typing only a few characters -- really brilliant!

Auto-complete uses the variable ~ac-modes~ to decide whether to enable
auto-completion in a particular mode; by default, ~org-mode~ (which interprets the
~TAB~ key) is not present in this list. So, to enable auto-completion in Org
mode, simply add it to the ~ac-modes~:

#+begin_example
(add-to-list 'ac-modes 'org-mode)
#+end_example

Popups:

- *Completion menu*

  Candidates suffix:
  + (nothing) -- means it is buffer string cache complete.
  + ~v~ -- Variable
  + ~f~ -- Function
  + ~s~ -- Symbol
  + ~c~ -- Constant
  + ~a~ -- Abbrev, YASnippet
  + ~d~ -- Dictionary, environment variable (e.g. ~LC_CTYPE~)
  + ~m~ -- Module

- *Quick help* (tooltip appearing at the side of the completion menu)

According to the default settings, completion is done by ~TAB~ or ~RET~:

- ~ac-expand~ (~TAB~) ::
     Select candidates in cycle.

- ~ac-complete~ (~RET~) ::
     Complete a selected candidate immediately.

There are other ways to select candidates:
- ~M-1~ to select candidate 1,
- ~M-2~ to select candidate 2,
- and so on (until 9).

Other operations are enabled temporarily *once the completion is started*:

- ~C-n~ or ~C-p~ ::
     Proceed to the *next match* or to the *previous match*.

- ~C-s~ (~ac-isearch~) ::
     *Filter* completion candidates.

- ~<C-down>~ or ~C-M-n~ (~ac-quick-help-scroll-down~) ::
     Scroll down quick help.

- ~<C-up>~ or ~C-M-p~ (~ac-quick-help-scroll-up~) ::
     Scroll up quick help.

- ~<F1>~ (or ~C-?~, ~ac-help~) ::
     Show additional *help* (for functions, arguments and objects) in *temporary
     buffer*.

     Use ~C-M-v~ (or ~C-M-S-v~) to scroll down (or up).

- ~M-<F1>~ (or ~C-M-?~, ~ac-persist-help~) ::
     Show additional *help* in *persistent buffer*.

Eventually, see [[http://stackoverflow.com/questions/19900949/how-to-make-auto-complete-work-with-yasnippet-and-abbrev][How to make auto-complete work with yasnippet and abbrev?]]

#+begin_src emacs-lisp :tangle no
;; Let's have snippets in the auto-complete dropdown
(add-to-list 'ac-sources 'ac-source-yasnippet)
#+end_src

#+begin_src emacs-lisp
  ;; Auto Completion.
  (with-eval-after-load "auto-complete-autoloads-XXX"
    (idle-require 'auto-complete-config)

    (global-set-key (kbd "C-/")     #'auto-complete)
    (global-set-key (kbd "C-S-SPC") #'auto-complete))

  (with-eval-after-load "auto-complete-config"

    ;; 6.1 Set a list of sources to use (by default + for some major modes)
    (ac-config-default))                ; ... and enable Auto-Complete mode in
                                        ; all buffers.

  (with-eval-after-load "auto-complete"
                                        ; Required by ESS.

    ;; 5.4 Completion will be started automatically by inserting 1 character.
    (setq ac-auto-start 1)              ; Also applies on arguments after
                                        ; opening parenthesis in ESS.

    ;; 7.5 Use `C-n/C-p' to select candidates (only when completion menu is
    ;; displayed).
    (setq ac-use-menu-map t)

    ;; Completion by TAB.
    (define-key ac-completing-map (kbd "<tab>")   #'ac-complete)

    ;; ;; Completion by RET.
    ;; (define-key ac-completing-map (kbd "<RET>") #'ac-complete)

    ;; Unbind some keys (inconvenient in Comint buffers).
    (define-key ac-completing-map (kbd "M-n")     nil)
    (define-key ac-completing-map (kbd "M-p")     nil)

    (define-key ac-completing-map (kbd "C-h")     #'ac-help)

    ;; Abort.
    (define-key ac-completing-map (kbd "C-g")     #'ac-stop)
    (define-key ac-completing-map (kbd "<left>")  #'ac-stop)
    ;; (define-key ac-completing-map (kbd "<right>") #'ac-stop)

    ;; Add other modes into `ac-modes'.
    (setq ac-modes
          (append ac-modes
                  '(change-log-mode
                    latex-mode
                    ;; org-mode
                    prog-mode           ; Programming modes.
                    snippet-mode
                    sql-mode
                    text-mode)))

    ;; 7.9 Just ignore case.
    (setq ac-ignore-case t)             ; ???

    ;; 8.1 Delay to completions will be available.
    (setq ac-delay 0)                   ; Faster than default 0.1.
    ;; Eclipse uses 500ms?

    ;; 8.2 Completion menu will be automatically shown.
    (setq ac-auto-show-menu 0.2)        ; [Default: 0.8].

    ;; 8.13 Delay to show quick help.
    (setq ac-quick-help-delay 0.5)

    ;; 8.15 Max height of quick help.
    (setq ac-quick-help-height 10)      ; Same as `ac-menu-height'.

    ;; 8.16 Limit on number of candidates.
    (setq ac-candidate-limit 100)

    ;; (setq ac-disable-inline t)
    ;; (setq ac-candidate-menu-min 0)

    ;; 11.1 Avoid Flyspell processes when auto completion is being started.
    (ac-flyspell-workaround)
#+end_src

#+begin_src emacs-lisp
)
#+end_src

XXX Test the following.

#+begin_src emacs-lisp :tangle no
    ;; Enable the drop down auto complete inside comment lines.
    (setq ac-disable-faces nil)
#+end_src

Integration of YASnipets:
https://github.com/joaotavora/yasnippet/issues/526

*** Company ("COMPlete ANYthing")

The best alternative to Auto-Complete seems to be Company mode.

#+begin_src emacs-lisp
(defun toggle-auto-complete-company-modes ()
  "Toggle beteen AC and Company modes."
  (interactive)
  (if auto-complete-mode
      (progn
        (auto-complete-mode -1)
        (company-mode 1)
        (message "Disable AC.  Enable Company")
        (sit-for 2))
    (auto-complete-mode 1)
    (company-mode -1)
    (message "Disable Company.  Enable AC")
    (sit-for 2)))

(global-set-key (kbd "<M-f1>") #'toggle-auto-complete-company-modes)
#+end_src

Besides that the maintainer of company-mode is incredibly competent and
friendly,

- Company mode is super easy to extend (whereas you often have to write 3-4
  times as much code to get the equivalent functionality out of AC backend);

- Company "just works", most of the time.  It's incredibly simple to use.

See https://github.com/company-mode/company-mode/issues/68 for a *feature
comparison* between both.

Completion will start automatically after you type a few letters.

Company mode has a unique take on auto-completion where it will reject
keystrokes if it doesn't match any possibilities.  It can also search available
completions and filter as well.

When the menu (with completion candidates) is displayed, press:

- ~up~ and ~down~ to select,
- ~RET~ or ~TAB~ to complete with the current selection
  (~company-complete-selection~).
- *Search through the completions* with ~C-s~, ~C-r~ and ~C-o~.
- Filter with ~C-M-s~.
- ~M-(digit)~ to quickly complete with one of the first 10 candidates.
- ~<right>~ to cancel completion.
- ~<F1>~ or ~C-h~ to *display the full documentation* for the selected symbol, or
- ~C-w~ to *show its definition*.

Not all back-ends support these last 2 commands.

#+begin_src emacs-lisp
  ;; Modular text completion framework.
  (with-eval-after-load "company-autoloads"
    (idle-require 'company)
    (with-eval-after-load "company"
      ;; Enable Company mode in all buffers ....
      (global-company-mode 1)

      (global-set-key (kbd "C-c y") #'company-yasnippet)
                                        ; Better than `helm-yas-complete' as
                                        ; `company-yasnippet' shows both the key
                                        ; and the replacement.
      ))
#+end_src

# #+begin_src emacs-lisp :tangle no
# ;; Hooks
# (add-hook 'web-mode-hook
#           #'(lambda ()
#               ;; Add ‘company-mode’ backend for ‘yasnippet’.
#               (set (make-local-variable 'company-backends)
#                    (append company-backends '((company-yasnippet))))
#
#               ;; Auto indent.
#               (local-set-key (kbd "RET") #'newline-and-indent)
#
#               ;; Disable smartparens in web-mode.
#               (setq smartparens-mode nil)))
#
# ;; See web-mode-imenu-regexp-list.
# #+end_src

**** Common

#+begin_src emacs-lisp
  (with-eval-after-load "company"

    ;; ... Except in some modes.
    (setq company-global-modes
          '(not ess-mode                ; In (i)ESS buffers, Auto-Complete is
                inferior-ess-mode       ; enabled by default.
                magit-status-mode
                help-mode))
#+end_src

By default, the list of candidates is sorted alphabetically, unless the backend
(or we) choose(s) to sort them in a different way.

#+begin_src emacs-lisp
    ;; ;; Sort candidates according to their occurrences.
    ;; (setq company-transformers '(company-sort-by-occurrence))
    ;; (setq company-transformers '(;; company-sort-by-statistics ;; unknown
    ;;                              company-sort-by-backend-importance))
#+end_src

#+begin_src emacs-lisp
    ;; Align annotations to the right tooltip border.
    (setq company-tooltip-align-annotations t)

    ;; Minimum prefix length for idle completion.
    (setq company-minimum-prefix-length 1)

    ;; Start completion immediately.
    (setq company-idle-delay 0)

    ;; Show quick-access numbers for the first ten candidates.
    (setq company-show-numbers t)

    ;; Selecting item before first or after last wraps around.
    (setq company-selection-wrap-around t)

    ;; Abort.
    ;; (define-key company-active-map (kbd "<right>") #'company-abort)
    ;; (define-key company-active-map (kbd "<left>")  #'company-abort)

    ;; Ignore some keys (inconvenient in Comint buffers).
    (define-key company-active-map (kbd "M-n")     nil)
    (define-key company-active-map (kbd "M-p")     nil)

    ;; Completion by TAB (insert the selected candidate).
    (define-key company-active-map (kbd "<tab>")   #'company-complete-selection)

    ;; Temporarily show the documentation buffer for the selection.  Also on F1 or C-h.
    (define-key company-active-map (kbd "C-?")     #'company-show-doc-buffer)

    ;;! Temporarily display a buffer showing the selected candidate in context.
    (define-key company-active-map (kbd "M-.")     #'company-show-location) ; XXX Also on C-w.


 (setq company-auto-complete
       #'(lambda ()
           (and (company-tooltip-visible-p)
                (company-explicit-action-p))))

 (setq company-continue-commands
   '(not save-buffer
         save-some-buffers
         save-buffers-kill-terminal
         save-buffers-kill-emacs
         comint-previous-matching-input-from-input
         comint-next-matching-input-from-input))
 (setq company-require-match nil)
#+end_src

#+begin_src emacs-lisp
    ;; Do nothing if the indicated candidate contains digits (actually, it will
    ;; try to insert the digit you type).
    (advice-add 'company-complete-number :around
     #'(lambda (fun n)
         (let ((cand (nth (+ (1- n) company-tooltip-offset)
                          company-candidates)))
           (if (string-match-p "[0-9]" cand)
               (let ((last-command-event (+ ?0 n)))
                 (self-insert-command 1))
             (funcall fun n))))
     '((name . "Don't complete numbers")))
#+end_src

*First* run the *indent* function, then try *completion* only if it didn't change
anything.

XXX The following does not work in Org files (~TAB~ does not expand nodes anymore)!

#+begin_src emacs-lisp :tangle no
    ;; See `tab-always-indent'.

    (defun leuven-indent-or-complete ()
      "Indent the current line; if point doesn't move, then try to complete."
      (interactive)
      (let ((p (point)))
        ;; (if (minibufferp)
        ;;     (minibuffer-complete)
        (call-interactively 'indent-for-tab-command)
        (when (and (= p (point))
                   (not (bolp))
                   (looking-at "\\_>"))
          (call-interactively 'company-complete-selection))))

    (define-key company-mode-map (kbd "<tab>") #'leuven-indent-or-complete)

    ;; (defun leuven--tab-fix ()
    ;;   (local-set-key (kbd "<tab>") #'leuven-indent-or-complete))
    ;;
    ;; (add-hook 'prog-mode-hook #'leuven--tab-fix)
#+end_src

Only trigger the tooltip on manual invocation, but still have the preview (of
the first candidate) show up immediately:

#+begin_src emacs-lisp :tangle no
    (defun company-pseudo-tooltip-unless-just-one-frontend--only-show-tooltip-when-invoked (orig-fun &rest args)
      (when (company-explicit-action-p)
        (apply orig-fun args)))
    (advice-add 'company-pseudo-tooltip-unless-just-one-frontend
       :around #'company-pseudo-tooltip-unless-just-one-frontend--only-show-tooltip-when-invoked)
#+end_src

From https://github.com/company-mode/company-mode/issues/87.

See also https://github.com/company-mode/company-mode/issues/123.

**** Quick-access letters

Provide letters as key bindings for completion of strings.

#+begin_src emacs-lisp
    ;; From https://github.com/company-mode/company-mode/issues/188
    (defun leuven-company-quick-access-key (numbered)
      "Replace default behavior of `company--show-numbers' function.
This example lists Azerty layout second row keys."
      (let ((value (mod numbered 10)))
        (format " %s"
                (cond ((eql value 1) "a")
                      ((eql value 2) "z")
                      ((eql value 3) "e")
                      ((eql value 4) "r")
                      ((eql value 5) "t")
                      ((eql value 6) "y")
                      ((eql value 7) "u")
                      ((eql value 8) "i")
                      ((eql value 9) "o")
                      (t "p")))))

    (setq company-show-numbers-function #'leuven-company-quick-access-key)

    (define-key company-active-map (kbd "M-a") (kbd "M-1"))
    (define-key company-active-map (kbd "M-z") (kbd "M-2"))
    (define-key company-active-map (kbd "M-e") (kbd "M-3"))
    (define-key company-active-map (kbd "M-r") (kbd "M-4"))
    (define-key company-active-map (kbd "M-t") (kbd "M-5"))
    (define-key company-active-map (kbd "M-y") (kbd "M-6"))
    (define-key company-active-map (kbd "M-u") (kbd "M-7"))
    (define-key company-active-map (kbd "M-i") (kbd "M-8"))
    (define-key company-active-map (kbd "M-o") (kbd "M-9"))
    (define-key company-active-map (kbd "M-p") (kbd "M-0"))
#+end_src

**** Tab

So, Company mode and YASnippet step on each other toes. So these functions are
to help TAB have the behaviour I expect. Attempt these actions, and do the first
one that works.

1. expand yas snippet
2. auto complete with company
3. indent

#+begin_src emacs-lisp :tangle no
(defun check-expansion ()
  (save-excursion
    (if (looking-at "\\_>") t
      (backward-char 1)
      (if (looking-at "\\.") t
        (backward-char 1)
        (if (looking-at "->") t nil)))))

(defun do-yas-expand ()
  (let ((yas/fallback-behavior 'return-nil))
    (yas/expand)))

(defun tab-indent-or-complete ()
  (interactive)
  (if (minibufferp)
      (minibuffer-complete)
    (if (or (not yas/minor-mode)
            (null (do-yas-expand)))
        (if (check-expansion)
            (company-complete-common)
          (indent-for-tab-command)))))
#+end_src

I became fairly frustrated trying to bind tab, so this is a fairly dirty way of
altering the keymaps of company and yas-minor modes.

#+begin_src emacs-lisp :tangle no
(defun bind-tab-properly ()
  "Binds tab to tab-indent-or-complete, overwritting yas and company bindings"
  (interactive)
  ;;overwrite yas and company tab mappings
  (define-key yas-minor-mode-map (kbd "<tab>") #'tab-indent-or-complete)
  (define-key yas-minor-mode-map (kbd "TAB")   #'tab-indent-or-complete)
  (define-key company-active-map [tab]         #'tab-indent-or-complete)
  (define-key company-active-map (kbd "TAB")   #'tab-indent-or-complete))

(add-hook 'company-mode-hook 'bind-tab-properly)
#+end_src

#+begin_src emacs-lisp
    )                                   ; with-eval-after-load "company".
#+end_src

With the following text (where "|" stands for the cursor):

#+begin_example
GOODBYE
good|
#+end_example

- the prefix "good" will match no word (no completion to "goodBYE"!) while
- the prefix "GOOD" will match "GOODBYE" only.

**** Prog modes

In "code" modes (see ~company-dabbrev-code-modes~) and their derivatives, Company
will -- by default -- complete only symbols, not text in comments or strings.

#+begin_src emacs-lisp
  ;; Dabbrev-like company-mode back-end for code.
  (with-eval-after-load "company-dabbrev-code"

    ;; ;; Search all other buffers
    ;; (setq company-dabbrev-code-other-buffers 'all)

    ;; Offer completions in comments and strings.
    (setq company-dabbrev-code-everywhere t)

    ;; ;; Ignore case when collecting completion candidates.
    ;; (setq company-dabbrev-code-ignore-case t)

    (when (locate-library "web-mode")
      (add-to-list 'company-dabbrev-code-modes 'web-mode))
    )
#+end_src

Problem:
Company: backend (company-dabbrev-code company-gtags company-etags
company-keywords) user-error: File /cygdrive/d/Users/fni/TAGS does not exist

Use command ~company-diag~ in bug reports.

**** Company-yasnippet

In a JS file, type ~al~, and see ~al -> alert~ in the Company popup. TAB'ing on that
entry will insert the code template!

#+begin_warning
The ~company-yasnippet~ backend should be used with care, because as long as there
are snippets defined for the current major mode, this backend will always shadow
backends that come after it.
#+end_warning

#+begin_src emacs-lisp
  (add-hook 'js2-mode-hook
            #'(lambda ()
                (set (make-local-variable 'company-backends)
                     '((company-dabbrev-code company-yasnippet)))))
#+end_src

#+begin_note
~company-backends~ is a variable defined in ~company.el~.

Documentation: The list of active back-ends (completion engines).

*Only one back-end is used at a time.* The choice depends on the order of the
items in this list, and on the values they return in response to the 'prefix'
command (see below). *But a back-end can also be a "grouped" one (see below).*

Grouped back-ends:

An element of ~company-backends~ can also itself be a list of back-ends, then it's
considered to be a "grouped" back-end.

When possible, commands taking a candidate as an argument are dispatched to the
back-end it came from. In other cases, the first non-nil value among all the
back-ends is returned.

The latter is the case for the ~prefix~ command. But if the group contains the
keyword ~:with~, the back-ends after it are ignored for this command.

The completions from back-ends in a group are merged (but only from those that
return the same ~prefix~).
#+end_note

**** Tern

- http://stackoverflow.com/questions/18102833/could-not-start-tern-server-in-emacs?rq=1
- https://github.com/syl20bnr/spacemacs/issues/5733
- https://github.com/ternjs/tern/issues/256
- https://github.com/angelozerr/tern.java/wiki/Tern-Eclipse-IDE
- https://github.com/angelozerr/tern.java/wiki/Getting-Started
- http://emmet.io/blog/sublime-tern/
- http://emacs.stackexchange.com/questions/3093/how-to-navigate-a-javascript-project
- https://truongtx.me/2014/04/20/emacs-javascript-completion-and-refactoring

Installing https://github.com/angelozerr/tern.java/wiki/Installation-Update-Site.

https://nodejs.org/download/release/latest/win-x64/

**** Text modes

In the other modes, Company will pass control to other back-ends
(e.g. ~company-dabbrev~).

#+begin_src emacs-lisp
  ;; Dabbrev-like company-mode completion back-end.
  (with-eval-after-load "company-dabbrev"

    ;; Only search in the current buffer
    (setq company-dabbrev-other-buffers nil) ; Prevent Company completing
                                             ; numbers coming from other files.

    ;; Don't ignore case when collecting completion candidates.
    (setq company-dabbrev-ignore-case nil)

    ;; Don't downcase the returned candidates.
    (setq company-dabbrev-downcase nil)
    ;; Fix problem with lowercased completions in comments and strings, in many
    ;; programming modes.

    ;; Skip invisible text (Org drawers, etc.).
    (setq company-dabbrev-ignore-invisible t))
#+end_src

XXX What about ~company-search-candidates~ vs ~company-filter-candidates~?

**** Company-quickhelp frontend

#+begin_src emacs-lisp
  (with-eval-after-load "company-quickhelp-autoloads"

    ;; Enable `company-quickhelp-mode'.
    (company-quickhelp-mode 1)

    ;; ;; Delay to show quick help.
    ;; (setq company-quickhelp-delay 0.5)

    ;; Maximum number of lines to show in the popup.
    (setq company-quickhelp-max-lines 10))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 29 ends here.
#+end_src

* Dired, the Directory Editor

#+begin_src emacs-lisp
;;* 30 (info "(emacs)Dired"), the Directory Editor

(leuven--chapter leuven-load-chapter-30-dired "30 Dired, the Directory Editor"
#+end_src

** Entering Dired

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Enter")

  ;; Directory-browsing commands.
  (with-eval-after-load "dired"

    (leuven--section "30.1 (emacs)Dired Enter")
#+end_src

#+begin_note
[[id:26d881f0-0f56-4259-9b31-eb4fecb08c88][ls-lisp]], Emacs's own *emulation of ~ls~* is used by *default on MS Windows* (which
does not have an ~ls~ program).  Though, it does not support as many options as
GNU ~ls~.
#+end_note

#+begin_src emacs-lisp
    ;; Switches passed to `ls' for Dired.
    (setq dired-listing-switches "-alF")
#+end_src

** Emulation of ~ls~ on MS-Windows
:PROPERTIES:
:ID:       26d881f0-0f56-4259-9b31-eb4fecb08c88
:END:

Use Emacs's own emulation of ~ls~ in all versions of Emacs.

#+begin_src emacs-lisp
;;** (info "(emacs)ls in Lisp")

    (leuven--section "G.4 (emacs)ls in Lisp")

    ;; Emulate insert-directory completely in Emacs Lisp.
    (when (require 'ls-lisp)

      ;; Disable the case sensitive sort of file names.
      (setq ls-lisp-ignore-case t)

      ;; Sort directories first.
      (setq ls-lisp-dirs-first t)

      ;; Use `ls-lisp' in all versions of Emacs (for Dired sorting to work OK!).
      (setq ls-lisp-use-insert-directory-program nil)
                                        ; [Default: nil for Windows, t otherwise]

      ;; Use ISO 8601 dates.
      (setq ls-lisp-format-time-list
            '("%Y-%m-%d %H:%M"
              "%Y-%m-%d %H:%M"))

      ;; Use localized date/time format.
      (setq ls-lisp-use-localized-time-format t))
#+end_src

** Navigation in the Dired Buffer

In Dired, ~M->~ and ~M-<~ never took me where I wanted to go.  Now, they do.

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Navigation")

    (leuven--section "30.2 (emacs)Dired Navigation")

    (defun dired-back-to-top ()
      (interactive)
      (goto-char (point-min))
      (dired-next-line 4))

    (define-key dired-mode-map [remap beginning-of-buffer] #'dired-back-to-top)

    (defun dired-jump-to-bottom ()
      (interactive)
      (goto-char (point-max))
      (dired-next-line -1))

    (define-key dired-mode-map [remap end-of-buffer] #'dired-jump-to-bottom)
#+end_src

#+begin_src emacs-lisp
    ;; Search in filenames (instead of in everything).
    (define-key dired-mode-map (kbd "C-s") #'dired-isearch-filenames)
#+end_src

** Deleting Files with Dired

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Deletion")

    (leuven--section "30.3 (emacs)Dired Deletion")

    ;; Recursive deletes allowed, after asking for each directory at top level.
    (setq dired-recursive-deletes 'top)
#+end_src

** Visiting Files in Dired

- ~^~ ::
     ~dired-up-directory~.

- ~o~ ::
     Open the file or directory in *another window*.

- ~C-o~ ::
     Open the file but stay on Dired buffer.

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Visiting")

    (leuven--section "30.5 (emacs)Dired Visiting")
#+end_src

*** Open file with default tool (open directory with Windows Explorer)

On top of the traditional ways, there are also these add-ons which open files
using external programs (such as PDF viewers), based on their extension.

One advantage is that using the traditional ~!~ (or ~X~) switch with Dired locks up
Emacs until you close the other program.  These add-ons do not and leave Emacs
free for continued used.

#+begin_note
Alternative

Nowadays, there's at least the built-in ~dired-do-async-shell-command~, bound to
~&~.

In addition to what others have mentioned, if you are on MS Windows then, after
loading ~w32-browser.el~ and ~dired+.el~, you can use item ~Open Associated Windows
App~ in the ~Single~ menu to open a file with the associated program.

Same thing for the marked files, using ~Oepn Associated Windows Apps~ in menus
~Multiple~ and ~Multiple > Marked Here and Below~.

And you can use item ~Single > ~Open in Windows Explorer~ to open a file or folder
in Windows Explorer.

You can also right-click on a file and pick ~Open Associated Windows App~ or ~Open
in Windows Explorer~.

There are key bindings for these as wel:

- ~M-RET~ or ~mouse-2~ :: open with associated proram
- ~C-RET~ :: open in Explorer
#+end_note

*************** TODO Read http://www.piprime.fr/1302/plus-qu-un-explorateur-de-fichiers-le-mode-dired-d-emacs/

These days, there are mature programs for launching an arbitrary file with an
appropriate viewer:

- ~xdg-open~ on GNU systems,

- ~open~ on Mac OS X,

  If ~xdg-open~ is not available, one can replace it with ~gnome-open~ or ~kde-open~.

- ~start~ on MS Windows.

  Though, it is a bad idea to use ~start~ on Windows: it has too many quirks
  regarding quoting of its command line.  Instead, just invoke the existing
  primitive ~w32-shell-execute~ with the ~open~ verb.  As a nice side effect, this
  will support Unicode file names, something that is currently impossible when
  you invoke an external command.

#+begin_src emacs-lisp :tangle no
    (defun helm-open-file-with-default-tool (file)
      "Open FILE with the default tool on this platform."
      (let ((program (cond (leuven--linux-p "xdg-open")
                           (leuven--mac-p "open")))
            process-connect-type)
        (if leuven--win32-p
            (helm-w32-shell-execute-open-file file)
          (start-process "helm-open-file-with-default-tool" nil program file))))
#+end_src

#+begin_src emacs-lisp :tangle no
    (defun dired-open ()
      (interactive)
      (let ((program (cond (leuven--linux-p "xdg-open")
                           (leuven--mac-p "open"))))
        (dired-do-shell-command program nil
                                (dired-get-marked-files t current-prefix-arg))))

    (define-key dired-mode-map (kbd "F") #'dired-open)
#+end_src

Reveal active file in Explorer:

#+begin_src emacs-lisp
    (defun browse-file-directory ()
      "Open the current file's directory however the OS would."
      (interactive)
      (if default-directory
          (browse-url-of-file (expand-file-name default-directory))
        (error "No `default-directory' to open")))

    (global-set-key (kbd "C-c r") #'browse-file-directory)
#+end_src

**** Ask a WWW browser to display file

Just ask a WWW browser to display the current file.

#+begin_src emacs-lisp
    ;; In Dired, ask a WWW browser to display the file named on this line.
    (define-key dired-mode-map (kbd "e") #'browse-url-of-dired-file) ; <C-RET>?

#+end_src

It works for files as well as for directories.

It opens the Windows Explorer for:

- the *current directory* when invoked on ~.~, and
- the *parent directory* when invoked on ~..~.

*************** TODO Mapcar on the browse-url function
See code of ~w32-dired-open-files-externally~.
*************** END

*************** TODO ~C-u RET~ opens dired on Org link
We should probably have the same type of key binding for opening Explorer from
Dired.
*************** END

**** MANY FILES at once (for Windows)

For those under Windows:

#+begin_src emacs-lisp
    ;; Open files using Windows associations.
    (when (or leuven--win32-p
              leuven--cygwin-p)
      (defun w32-dired-open-files-externally (&optional arg)
        "In Dired, open the marked files (or directories) with the default
      Windows tool."
        (interactive "P")
        (mapcar
         #'(lambda (file)
             (w32-shell-execute "open" (convert-standard-filename file)))
         (dired-get-marked-files nil arg)))

      ;; ;; Bind it to `E' in Dired mode.
      ;; (define-key dired-mode-map (kbd "E") #'w32-dired-open-files-externally)
      )
#+end_src

**** ARCHIBUS

#+begin_src emacs-lisp
    (with-eval-after-load "dired"
      (define-key dired-mode-map (kbd "C-c v")
         #'(lambda ()
             "Ask a WWW browser to load ARCHIBUS View file."
             (interactive)
             (let ((archibus-prefix "http://localhost:8080/archibus/"))
               (browse-url (concat archibus-prefix (dired-get-filename 'no-dir t)))))))
#+end_src

*** Open file with ~eww~

#+begin_src emacs-lisp
    ;; Open current file with eww.
    (defun dired-open-with-eww ()
      "In Dired, visit (with eww) the file named on this line."
      (interactive)
      (eww-open-file (file-name-sans-versions (dired-get-filename) t)))

    ;; Add a binding "W" -> `dired-open-with-eww' to Dired.
    (define-key dired-mode-map (kbd "W") #'dired-open-with-eww)
#+end_src

** Operating on Files

#+begin_src emacs-lisp
;;** (info "(emacs)Operating on Files")

    (leuven--section "30.7 (emacs)Operating on Files")

    ;; Try to guess a default target directory (if there is a Dired buffer
    ;; displayed in the next window).
    (setq dired-dwim-target t)

    ;; Copy recursively without asking.
    (setq dired-recursive-copies 'always)
#+end_src

** Updating the Dired Buffer

#+begin_warning
The following code block is currently disabled, because it causes problems with
Org and PDF LaTeX: when we've opened the TeX file, to compile it from LaTeX
because an error has been reported (with no details), then the TeX file blocks
the next automatic exports (~C-u C-c C-e~), asking for confirmation because the
TeX buffer is open...

#+begin_example
Reverting buffer `prestations/'.
prestations-2013-06.tex changed on disk; really edit the buffer? (y, n, r or C-h) n
#+end_example
#+end_warning

#+begin_src emacs-lisp :tangle no
    (add-hook 'dired-mode-hook
              #'(lambda ()
                  ;; Auto-refresh Dired on file change.
                  (auto-revert-mode)))
#+end_src

Maybe the following fixes this above problem?

#+begin_src emacs-lisp
;;** (info "(emacs)Dired Updating")

    (leuven--section "30.15 (emacs)Dired Updating")

    ;; Automatically revert Dired buffer *on revisiting*.
    (setq dired-auto-revert-buffer t)
#+end_src

Press ~s~ then ~s~, ~x~, ~t~, ~n~ or ~d~ to sort by Size, eXtension, *Time*, *Name* or name
grouping Dirs first:

#+begin_src emacs-lisp
    ;; Dired sort.
    (try-require 'dired-sort-map)
#+end_src

** Dired and ~find~

For searches in Dired, see ~dired-do-search~ (~A~).
- Search through all *marked files* for a match for regexp
- Stops when a match is found
- To continue searching for next match, use command "M-,"

#+begin_src emacs-lisp
;;** (info "(emacs)Dired and Find")

    (leuven--section "30.16 (emacs)Dired and Find")
#+end_src

#+begin_src emacs-lisp :tangle no
    ;; ;; What to use in place of `-ls' as the final argument.
    ;; (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
    ;; ;; Quicker to collate the matches and then use `xargs' to run the command
    ;; ;; (variable defined in `find-dired.el').
#+end_src

#+begin_src emacs-lisp
    ;; Search for files with names matching a wild card pattern and Dired the
    ;; output.
    (global-set-key (kbd "C-c 1") #'find-name-dired)
                                        ; Case insensitive if
                                        ; `read-file-name-completion-ignore-case'
                                        ; is non-nil.

    ;; `find-grep-dired' case insensitivity.
    (setq find-grep-options "-i -q")

    ;; Search for files with contents matching a wild card pattern and Dired the
    ;; output.
    (global-set-key (kbd "C-c 2") #'find-grep-dired)
#+end_src

** Editing the Dired Buffer

~Wdired~ mode is *great for renaming (a lot of) files* in a directory, as it allows
*editing the Dired buffer* like a text file, using all the power of Emacs.  That
is, one can use keyboard macros, search and replace, rectangle mode (great for
adding prefixes to file names), flip mode bits with the mouse, etc.!

To enter it, type ~C-x C-q~.

#+begin_src emacs-lisp
;;** (info "(emacs)Wdired")

    (leuven--section "30.17 Editing the (emacs)Wdired Buffer")

    ;; Put a Dired buffer in a mode in which filenames are editable.
    (with-eval-after-load "wdired"

      ;; Permissions bits of the files are editable.
      (setq wdired-allow-to-change-permissions t))
#+end_src

** Viewing Image Thumbnails in Dired

~M-x image-dired~ and choose a directory with images.

Prerequisites:
- [[http://www.imagemagick.org.][ImageMagick]] package
- JpegTRAN program
- [[http://www.sno.phy.queensu.ca/~phil/exiftool/][exiftool]] to *edit comments and tags* for each image.

Key bindings:

- C-t d ::
     ~image-dired-display-thumbs~ (on marked files).

- C-t e ::
     ~image-dired-dired-edit-comment-and-tags~.

For more information, see:
- http://www.emacswiki.org/Tumme
- http://wikemacs.org/wiki/Image-dired

#+begin_src emacs-lisp
;;** (info "(emacs)Image-Dired")

    (leuven--section "30.18 Viewing Image Thumbnails in Dired")

    ;; Use Dired to browse and manipulate your images.
    (with-eval-after-load "image-dired"

      ;; Maximum number of files to show before warning the user.
      (setq image-dired-show-all-from-dir-max-files 100)

      ;; Size of button-like border around thumbnails.
      (setq image-dired-thumb-relief 0)

      ;; Size of the margin around thumbnails.
      (setq image-dired-thumb-margin 4))
#+end_src

** Other Dired features

To copy the *name* of the file at point (or the folder you're looking at in Dired)
into the kill ring (in order to make use of it elsewhere), use
~dired-copy-filename-as-kill~, which is bound to ~w~ in Dired.

#+begin_tip
Use ~0 w~ to put the *full path*.
#+end_tip

** Dired "extra" features

Extra Dired functionality:

- You can *jump to the Dired buffer* corresponding to the current buffer by
  pressing *~C-x C-j~* (~dired-jump~).  If in Dired already, pop up a level and goto
  old directory's line.

  *Standard* alternative: ~C-x d RET~, though it doesn't set point on the right
  file.

- ~dired-x~ also has a feature to "guess" the right shell command and the right
  external viewer for documents (see ~dired-guess-shell-alist-user~)

#+begin_src emacs-lisp
;;** Dired Extra

    (leuven--section "30.XX (dired-x)Top")

    (require 'dired-x)                  ; with-eval-after-load "dired" ends here.


    (defadvice dired-jump (around leuven-dired-jump activate)
      "Ask for confirmation for buffers of 1,400,000 bytes or more."
      (when (or (< (buffer-size) 1400000)
                (y-or-n-p "Are you sure you want to do this? (This may take time... Use `C-x d' instead) "))
        ad-do-it))
    )
#+end_src

** Dired+

Extensions to Dired:

- Provide fancy *highlighting*.

- Let you act on sets of marked files in subdirs, recursively, for example.

There are global key bindings that Dired+ makes:

- ~C-x D~ :: ~diredp-dired-union~
- ~C-x E~ :: ~diredp-add-to-dired-buffer~
- ~C-x C-M-f~ :: ~diredp-fileset~
- ~C-x R~ :: ~diredp-dired-recent-dirs~

These are not bindings for Dired mode.  They are global bindings that set up
a Dired buffer.  They are thus similar to the default global bindings ~C-x d~ and
~C-x C-j~.

#+begin_src emacs-lisp
;;** Dired+

  (leuven--section "30.XX Dired+")

  (when (try-require 'dired+-XXX) ; XXX

    ;; Don't hide details in Dired.
    (setq diredp-hide-details-initially-flag nil)

    ;; Don't display the next Dired buffer the same way as the last.
    (setq diredp-hide-details-propagate-flag nil)

    ;; Don't wrap "next" command around to buffer beginning.
    (setq diredp-wrap-around-flag nil)

    ;; Dired `find-file' commands reuse directories.
    (diredp-toggle-find-file-reuse-dir 1)

    ;; Up, reusing Dired buffers.
    (define-key dired-mode-map (kbd "C-x C-j")
      #'diredp-up-directory-reuse-dir-buffer))
#+end_src

** VC diff highlighting

Like Git-gutter, Diff-hl shows you *which lines were modified compared to the
latest commit* -- it supports SVN, Git, and other VC systems!

#+begin_src emacs-lisp
;;** Diff-hl

  (leuven--section "30.XX Diff-hl")

  ;; Enable VC diff highlighting on the side of a Dired window.
  (with-eval-after-load "diff-hl-autoloads"
    (add-hook 'dired-mode-hook #'diff-hl-dired-mode))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 30 ends here.
#+end_src

* The Calendar and the Diary

#+begin_src emacs-lisp
;;* 31 The (info "(emacs)Calendar/Diary")

(leuven--chapter leuven-load-chapter-31-calendar-diary "31 The Calendar and the Diary"
#+end_src

** Calendar Motion

#+begin_src emacs-lisp
;;** 31.1 (info "(emacs)Calendar Motion")

  (leuven--section "31.1 (emacs)Calendar Motion")

  ;; Years must be written in full.
  (setq diary-abbreviated-year-flag nil)

  ;; Set the style of calendar and diary dates to ISO (how to interpret the
  ;; dates).
  (setq calendar-date-style 'iso)

  ;; Week in the calendar begins on Monday.
  (setq calendar-week-start-day 1)

  ;; Mark all visible dates that have diary entries.
  (when (file-exists-p "~/diary")
    (setq calendar-mark-diary-entries-flag t))

  ;; Mark the current date (by changing its face) after generating a calendar,
  ;; if today's date is visible.
  (add-hook 'calendar-today-visible-hook #'calendar-mark-today)
#+end_src

** Scroll Calendar

#+begin_src emacs-lisp
;;** 31.2 (info "(emacs)Scroll Calendar")

  (leuven--section "31.2 (emacs)Scroll Calendar")

  ;; Fix foolish calendar-mode scrolling after loading `calendar.el'.
  (add-hook 'calendar-load-hook
            #'(lambda ()
                (define-key calendar-mode-map (kbd ">") #'calendar-scroll-left)
                (define-key calendar-mode-map (kbd "<") #'calendar-scroll-right)))
#+end_src

** Times of Sunrise/Sunset

#+begin_src emacs-lisp
;;** 31.7 Times of (info "(emacs)Sunrise/Sunset")

  (leuven--section "31.7 Times of (emacs)Sunrise/Sunset")

  ;; ;; Calendar functions for solar events.
  ;; (with-eval-after-load "solar"
  ;;
  ;;   ;; Name of the calendar location.
  ;;   (setq calendar-location-name "Leuven, BE")
  ;;
  ;;   ;; Latitude of `calendar-location-name'.
  ;;   (setq calendar-latitude 50.88)
  ;;
  ;;   ;; Longitude of `calendar-location-name'.
  ;;   (setq calendar-longitude 4.70))
#+end_src

** Diary

The Emacs diary keeps track of appointments or other events on a daily basis, in
conjunction with the calendar.  To use the diary feature, you must first create
a "diary file" containing a list of events and their dates.

But [[id:737b836b-ac1f-4120-94ca-c9e0282268f0][Org]] outperforms it!

** Appointments

#+begin_src emacs-lisp
;;** 31.11 (info "(emacs)Appointments")

  (leuven--section "31.11 (emacs)Appointments")

  ;; Insinuate appt if `diary-file' exists.
  (if (file-readable-p "~/diary")
      (try-require 'appt)               ; Requires `diary-lib', which requires
                                        ; `diary-loaddefs'.
    (message "[Appointment reminders lib `appt' not loaded (no diary file found)]"))

  (with-eval-after-load "appt"

    ;; Send the first warning 60 minutes before an appointment.
    (setq appt-message-warning-time 60) ; [default: 12]

    ;; Warn every 15 minutes.
    (setq appt-display-interval 15)     ; [default: 3]
#+end_src

Send notifications using ~notifications-notify~ (which was added in Emacs 24).
It uses ~notify-send~ (if the ~libnotify-bin~ Ubuntu package is installed).

*************** TODO For Windows users: use `todochicku.el' (cross-platform?) and the snarl notifier

Or better look at the ~alert~ package?

*************** TODO Diff between shell-command and call-process?  Blocking call?

#+begin_src emacs-lisp
    ;; Use a separate window to display appointment reminders.
    (setq appt-display-format 'window)

    ;; Function called to display appointment reminders *in a window*.
    (setq appt-disp-window-function (function leuven--appt-display))

    (defun leuven--appt-display (mins-to-appt current-time notification-string)
      "Display a reminder for appointments.
    Use `libnotify' if available and if display is graphical, or fall back on a
    message in the echo area."
      (or (listp mins-to-appt)
          (setq notification-string (list notification-string)))
      (dotimes (i (length notification-string))
        (cond ((and (display-graphic-p)
                    (executable-find "notify-send"))
               (shell-command
                (concat "notify-send "
                        "-i /usr/share/icons/gnome/32x32/status/appointment-soon.png "
                        "-t 1000 "
                        "'Appointment' "
                        "'" (nth i notification-string) "'")))
              (t
               (message "[%s]" (nth i notification-string))
               (sit-for 1)))))
#+end_src

#+begin_src emacs-lisp
    ;; Turn appointment checking on (enable reminders).
    (when leuven-verbose-loading
      (message "[Enable appointment reminders...]"))
    (appt-activate 1)
    (when leuven-verbose-loading
      (message "[Enable appointment reminders... Done]"))
#+end_src

#+begin_src emacs-lisp
    ;; Enable appointment notification, several minutes beforehand.
    (add-hook 'diary-hook #'appt-make-list)
#+end_src

#+begin_src emacs-lisp
    (with-eval-after-load "org-agenda"

      ;; Keep your appointment list clean: if you delete an appointment from
      ;; your Org agenda file, delete the corresponding alert.
      (defadvice org-agenda-to-appt (before leuven-org-agenda-to-appt activate)
        "Clear the existing `appt-time-msg-list'."
        (setq appt-time-msg-list nil))

      ;; Add today's appointments (found in `org-agenda-files') each time the
      ;; agenda buffer is (re)built.
      (add-hook 'org-agenda-finalize-hook #'org-agenda-to-appt)
                                          ;! Don't use the `org-agenda-mode-hook'
                                          ;! because the Org agenda files would be
                                          ;! opened once by `org-agenda-to-appt',
                                          ;! and then killed by
                                          ;! `org-release-buffers' (because
                                          ;! `org-agenda-to-appt' closes all the
                                          ;! files it opened itself -- as they
                                          ;! weren't already opened), to be
                                          ;! finally re-opened!
      )
#+end_src

#+begin_src emacs-lisp
    )                                   ; with-eval-after-load "appt" ends here.
#+end_src

** Advanced Calendar/Diary Usage

#+begin_src emacs-lisp
;;** 31.15 (info "(emacs)Advanced Calendar/Diary Usage")

  (leuven--section "31.15 (emacs)Advanced Calendar/Diary Usage")

  ;; Get rid of some holidays.
  (setq holiday-general-holidays nil)   ; Too U.S.-centric holidays.
  (setq holiday-oriental-holidays nil)  ; Oriental holidays.
  (setq holiday-hebrew-holidays nil)    ; Religious holidays.
  (setq holiday-islamic-holidays nil)   ; Religious holidays.
  (setq holiday-bahai-holidays nil)     ; Baha'i holidays.
  (setq holiday-solar-holidays nil)     ; Sun-related holidays.

  ;; Mark dates of holidays in the calendar window.
  (setq calendar-mark-holidays-flag t)
#+end_src

After the calendar is loaded, ~calendar-holidays~ is the list of notable days for
the command ~M-x holidays~.

#+begin_src emacs-lisp
  (defun leuven-insert-current-date (prefix)
    "Insert the current date in ISO format.
  With one PREFIX argument, add day of week.  With two PREFIX arguments, add day
  of week and time."
    (interactive "P")
    (let ((format (cond ((not prefix) "%Y-%m-%d")
                        ((equal prefix '(4)) "%Y-%m-%d %a")
                        ((equal prefix '(16)) "%Y-%m-%d %a %H:%M"))))
      (insert (format-time-string format))))

  (global-set-key (kbd "C-c .") #'leuven-insert-current-date)
#+end_src

** Calendar framework

After displaying your ~calfw~ buffer, you can get a HTML buffer with ~M-x
htmlfontify-buffer~.

#+begin_warning
~Calfw~ requires ~Google-maps~!?
#+end_warning

#+begin_src emacs-lisp
;;* Calendar view framework on Emacs

  ;; Calendar view framework on Emacs.
  (with-eval-after-load "calfw"

    ;; Unicode characters.
    (setq cfw:fchar-junction ?╋
          cfw:fchar-vertical-line ?┃
          cfw:fchar-horizontal-line ?━
          cfw:fchar-left-junction ?┣
          cfw:fchar-right-junction ?┫
          cfw:fchar-top-junction ?┯
          cfw:fchar-top-left-corner ?┏
          cfw:fchar-top-right-corner ?┓))

  ;; Calendar view for org-agenda.
  (with-eval-after-load "calfw-org"

    ;; Remove some strings (tags and filenames) from item summary.
    (defun cfw:org-summary-format (item)
      "Format an item (How should it be displayed?)."
      (let* ((time (cfw:org-tp item 'time))
             (time-of-day (cfw:org-tp item 'time-of-day))
             (time-str (and time-of-day
                            (format "%02i:%02i "
                                    (/ time-of-day 100)
                                    (% time-of-day 100))))
             (category (cfw:org-tp item 'org-category))
             (tags (cfw:org-tp item 'tags))
             (marker (cfw:org-tp item 'org-marker))
             (buffer (and marker (marker-buffer marker)))
             (text (cfw:org-extract-summary item))
             (props (cfw:extract-text-props item 'face 'keymap)))
        (propertize
         (concat
          (if time-str (apply 'propertize time-str props)) text " "
          ;; (and buffer (buffer-name buffer))
          )
         'keymap cfw:org-text-keymap
         ;; Delete the display property, since displaying images will break our
         ;; table layout.
         'display nil))))
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 31 ends here.
#+end_src

* Sending Mail

Minimal configuration for sending a bug report, for example.

#+begin_src emacs-lisp
;;* 32 (info "(emacs)Sending Mail")

(leuven--chapter leuven-load-chapter-32-sending-mail "32 Sending Mail"

  ;; Full name of this user.
  (setq user-full-name "John Doe")

  ;; Full mailing address of this user
  ;; (used in MAIL envelope FROM, and to select the default personality ID).
  (setq user-mail-address "john.doe@example.com")

  ;; Sending mail.
  (setq send-mail-function 'smtpmail-send-it)

  ;; Default SMTP server (overriden by `smtpmail-smtp-server').
  (setq smtpmail-default-smtp-server "smtp")
                                        ; SMTP process must be running
                                        ; there... and it should be Google's own
                                        ; mail server for GMail user mail
                                        ; addresses...

  ;; ;; SMTP service port number.
  ;; (setq smtpmail-smtp-service 587)

)                                       ; Chapter 32 ends here.
#+end_src

* Gnus

#+begin_src emacs-lisp
;;* 34 (info "(emacs)Gnus")

(leuven--chapter leuven-load-chapter-34-gnus "34 Gnus"

  (global-set-key (kbd "C-c n")
    #'(lambda ()
        (interactive)
        (switch-or-start 'gnus "*Group*")))

  ;; Directory beneath which additional per-user Gnus-specific files are placed.
  (setq gnus-directory "~/.gnus.d/")    ; Should end with a directory separator.

  ;; A newsreader for GNU Emacs.
  (with-eval-after-load "gnus"

    ;; Package to compose an outgoing mail (Message, with Gnus paraphernalia).
    (setq mail-user-agent 'gnus-user-agent)

    ;; Reading mail with Gnus.
    (setq read-mail-command 'gnus))

)                                       ; Chapter 34 ends here.
#+end_src

* Document Viewing

If ~doc-view~ is not showing the PDF files as images in Emacs, it may be
because:

- no PNG support is available in Emacs (see [[id:9432da83-fa9d-4466-a4da-57f33d662bbd][Images]]), or
- some conversion utility for PDF files (Ghostscript) is not on your ~PATH~.

In that case, ~doc-view~ falls back to show you the plain text contents of the PDF
if ~doc-view-pdftotext-program~ is on your ~PATH~.

#+begin_src emacs-lisp
;;* 36 (info "(emacs)Document View")

(leuven--chapter leuven-load-chapter-36-document-view "36 Document Viewing"

  ;; View PDF/PostScript/DVI files in Emacs.
#+end_src

#+begin_verse
From Tassilo Horn:

>> https://github.com/politza/pdf-tools (available through MELPA).
>
> Oh, that looks pretty impressive.  I haven't used it, though, so I
> cannot help with this.

Ok, now I had to check it out, and Andreas, it's a really superb
package.  I'm gonna use that now for reading PDF files instead of
doc-view (where I'm the author) and Evince (which I use due to
doc-view's limitations).

But Troy is correct.  The PDF he links makes emacs freeze, although I've
been able to recover by hitting `C-g' repeatedly.  The result was that
the raw PDF data was shown.

Before I had opened that file successfully with doc-view and then did
M-x pdf-view-mode.  That worked.  When doing it that way, it seems some
if not all of PDF Tools minor modes aren't active, so I guess one of
them does something that triggers the freeze.

Andreas, do you plan to propose PDF Tools for inclusion in Emacs?  IMO,
that's really a package anybody's gonna love.  (Oh my god, how well the
syntex stuff/AUCTeX integration works!)
#+end_verse

PDF Tools (~pdf-view-mode~) is a major mode for viewing PDFs in Emacs similar (but
much more advanced) than ~doc-view-mode~.

It offers many features:
- highlighting search,
- highlighting selection,
- annotate,
- content tree.

It's the best PDF viewer on GNU/Linux (including the ones not running in Emacs).

#+begin_src emacs-lisp :tangle no
  (when (and leuven--linux-p
             (not (executable-find "epdfinfo")))
    (with-eval-after-load "pdf-tools-autoloads"
      (pdf-tools-install)))
#+end_src

** Navigation

~doc-view~ integrates with the usual bookmark facility.  So, simply use ~C-x r m~
(~bookmark-set~) to jump back to the last page you've read in a PDF document.

** Conversion

In ~doc-view-mode~, you can use ~C-s~ to do regexp search on the page images.

In addition, by pressing ~C-c C-t~, you can open the *text*-only representation
(actually, the output of the command ~pdftotext~) of the current doc in a new
buffer, which is more suitable for heavy manipulation of the text of the PDF.

Another option, without ~doc-view~, is ~! pdtotext ? - RET~.

~doc-view-enlarge~ (~+~) and ~doc-view-shrink~ (~-~) work fine to zoom in or out.

#+begin_src emacs-lisp
)                                       ; Chapter 36 ends here.
#+end_src

* Web Browsing

** EWW (Emacs Web Browser)

~EWW~ is the new Web browser for Emacs.

See https://www.gnu.org/software/emacs/manual/html_node/eww/index.html.

~M-x eww~ asks EWW to browse a URL.

- ~&~ (~eww-browse-with-external-browser~) ::
     Open the Web page in an *external browser* (when JavaScript is needed or the
     "design" is just too bad).

- F (eww-toggle-fonts) ::
     Toggle whether to use variable-pitch fonts or not.  The user can also
     customize the ~shr-use-fonts~ variable.

- R (eww-readable) ::
     Try do identify the *main textual parts of a web page* and *display only* that,
     leaving menus and the like off the page.

- D (eww-toggle-paragraph-direction) ::
     Toggle the paragraph direction between left-to-right and right-to-left.

- S ::
     List all eww buffers, and allow managing them.

HTTPS pages with valid certificates have headers marked in green, while invalid
certificates are marked in red.

*************** TODO See package ~eww-lnum~ (or ~avy~?)
(define-key eww-mode-map (kbd "f") #'eww-lnum-follow)
(define-key eww-mode-map (kbd "F") #'eww-lnum-universal)
*************** END

* Running Shell Commands from Emacs

See customizations at http://snarfed.org/why_i_run_shells_inside_emacs.

#+begin_src emacs-lisp
;;* 38 Running (info "(emacs)Shell") Commands from Emacs

(leuven--chapter leuven-load-chapter-38-shell "38 Running Shell Commands from Emacs"
#+end_src

#+begin_src emacs-lisp
  ;; Transform shell names to what they really are.
  (with-eval-after-load "sh-script"

    (add-to-list 'sh-alias-alist '(sh . bash)))

  ;; ;; Use shell from Cygwin/MinGW.
  ;; (setq shell-file-name "bash")
  ;; (setenv "SHELL" "/bin/bash")
  ;; (setq explicit-bash-args '("-i")) ; --noediting added in Emacs 24.4
  ;; (setq explicit-sh-args '("-i"))
#+end_src

** Single Shell

~M-!~ (~shell-command~) reads a line of text using the minibuffer and executes it as
a shell command, in a subshell made just for that command.

~M-|~ (~shell-command-on-region~) passes the contents of the region as the standard
input to the shell command.  By prefixing it with ~C-u~, it deletes the old region
and *replaces* it with the output from the shell command.

#+begin_src emacs-lisp
;;** 38.1 Single Shell

  (leuven--section "38.1 Single Shell")

  ;; Force interactive behavior (to get my handy shell aliases).
  ;; FIXME Fix for Zsh (zsh:1: command not found: shopt)
  ;; (defadvice shell-command (before leuven-shell-command activate)
  ;;   (ad-set-arg 0
  ;;               (concat "source ~/.bashrc; shopt -s -q expand_aliases;\n "
  ;;                       (ad-get-arg 0))))

  ;; ;; For single shell commands (= "the" reference).
  ;; (setq shell-file-name                 ; Must be in the `PATH'.
  ;;       (or (ignore-errors
  ;;             (file-name-nondirectory (or (executable-find "zsh")
  ;;                                         (executable-find "bash")
  ;;                                         (executable-find "sh"))))
  ;;           (when leuven--win32-p "cmdproxy.exe")))
  ;;
  ;; ;; Use `shell-file-name' as the default shell.
  ;; (setenv "SHELL" shell-file-name)
  ;;
  ;; ;; Switch used to have the shell execute its command line argument.
  ;; (setq shell-command-switch "-c")      ; `/c' did not work with XEmacs.

  ;; Quote process arguments to ensure correct parsing on Windows.
  (setq w32-quote-process-args t)

  ;; ;; Workaround for Cygwin when 'shell-file-name' is 'bash'.
  ;; (setq null-device "/dev/null"))
#+end_src

The above assignments may *NOT* be done *in an eval-after-load* as those variables
are used by the (La)TeX modes (default + AUCTeX) among others.

** Interactive Subshell

To run a subshell interactively, type ~M-x shell~.  This creates (or reuses)
a buffer named ~*shell*~, and runs a shell subprocess with input coming from and
output going to that buffer.

#+begin_src emacs-lisp
;;** 38.2 Interactive Subshell

  (leuven--section "38.2 Interactive Subshell")

  ;; ;; For the interactive (sub)shell (and AUCTeX compilation?).
  ;; (setq explicit-shell-file-name shell-file-name)
#+end_src

** Shell Mode
:PROPERTIES:
:ID:       9e938c3d-3752-4c12-b3a8-cc12cdcdfd88
:END:

*** Entering commands and fixing mistakes

- ~RET~ ::
     *Execute* the *command (on* the *current line)*.

- ~C-c C-u~ ::
     *Delete input* (from the prompt) up to point (equivalent to ~C-u~ in Unix
     shells).

*** Completion of filenames

- ~M-?~ ::
     Display a list of possible completions for the filename at point.

*** Manipulating the output from the last command

# - ~C-c C-e~ ::
#      Move *last line of output* from your last command *to bottom of window*,
#      showing the maximum of the output.

- ~C-c C-r~ ::
     *Show output* from last command (move first line of output to top of window).

- ~C-c C-o~ ::
     *Delete output* (only) from last command.

*** Sending signals

- ~C-c C-c~ ::
     Interrupt current job (equivalent to ~C-c~ in Unix shells, ~BREAK~ signal).

- ~C-c C-z~ ::
     Suspend or stop current job (equivalent to ~C-z~ in Unix shells, ~STOP~
     signal).

- ~C-c C-d~ ::
     Send ~EOF~ character.

#+begin_src emacs-lisp
;;** 38.3 Shell Mode

  (leuven--section "38.3 Shell Mode")

  ;; General command-interpreter-in-a-buffer stuff (Shell, SQLi, Lisp, R,
  ;; Python, ...).
  ;; (try-require 'comint)
  ;; (with-eval-after-load "comint"

    ;; Comint prompt is read only.
    (setq comint-prompt-read-only t)    ; Text is read-only (in ESS)?

    ;; No duplicates in command history.
    (setq-default comint-input-ignoredups t)

    ;; Input to interpreter causes windows showing the buffer to scroll
    ;; (insert at the bottom).
    (setq-default comint-scroll-to-bottom-on-input t)

    ;; Output to interpreter causes windows showing the buffer to scroll
    ;; (add output at the bottom).
    (setq-default comint-move-point-for-output t)

    ;; Maximum size in lines for Comint buffers.
    (setq comint-buffer-maximum-size (* 5 1024))
                                        ; If the function
                                        ; `comint-truncate-buffer' is added to
                                        ; `comint-output-filter-functions'.

    ;; Strip `^M' characters.
    (add-to-list 'process-coding-system-alist
                 '("sh" . (undecided-dos . undecided-unix))) ; `es' process.
    (add-to-list 'process-coding-system-alist
                 '("bash" . (undecided-dos . undecided-unix)))
    (add-to-list 'process-coding-system-alist
                 '("zsh" . (undecided-dos . undecided-unix)))

    ;; Show completion list when ambiguous.
    (setq comint-completion-autolist t)

    (defun leuven-comint-clear-buffer ()
      "Clear the Comint buffer."
      (interactive)
      (let ((comint-buffer-maximum-size 0))
        (comint-truncate-buffer)))

    (with-eval-after-load "comint"
      (define-key comint-mode-map (kbd "C-c C-k") #'leuven-comint-clear-buffer))

;; )
#+end_src

*************** TODO Command Prompt Here in Emacs
See http://tsdh.wordpress.com/category/lisp/emacs-lisp/ to quickly open a Shell
bufffer from Emacs.
*************** END

** Shell Prompts

#+begin_src emacs-lisp
;;** 38.4 Shell Prompts

  (leuven--section "38.4 Shell Prompts")

  ;; Regexp to match prompts in the inferior shell.
  (setq shell-prompt-pattern "^[^#$%>\n]*[#$%>] *")

  ;; Regexp to recognize prompts in the inferior process.
;;   (setq comint-prompt-regexp shell-prompt-pattern) ; Used as well by SQLi!
                                        ;! Only used if the variable
                                        ;! `comint-use-prompt-regexp' is non-nil.
#+end_src

** Shell Command History

#+begin_src emacs-lisp
;;** 38.5 Shell Command History

  (leuven--section "38.5 Shell Command History")

  (with-eval-after-load "comint"

    ;; Rejects short commands.
    (setq comint-input-filter
      #'(lambda (str)
          (and (not (string-match "\\`\\s *\\'" str))
               (> (length str) 2))))    ; Ignore '!!' and kin.
#+end_src

*** Shell History Ring

- ~C-p~ (or ~<up>~) ::
     Fetch the next *earlier* command in the history (doesn't execute it).

- ~C-n~ (or ~<down>~) ::
     Fetch the next *later* command in the history (doesn't execute it).

- ~M-p~ (or ~<C-up>~) ::
     Fetch the next *earlier* command in the history matching the string typed so
     far (doesn't execute it).

- ~M-n~ (or ~<C-down>~) ::
     Fetch the next *later* command in the history matching the string typed so
     far (doesn't execute it).

- ~M-r~ ::
     Begin an incremental *regexp search of old commands*.

- ~C-c C-l~ ::
     Display the current buffer's *history* of shell commands.

#+begin_src emacs-lisp
    ;; Cycle backwards/forwards through input history.
    (define-key comint-mode-map
      (kbd "C-p") #'comint-previous-input) ; Shell.
    (define-key comint-mode-map
      (kbd "<up>") #'comint-previous-input) ; Shell + RStudio.
    (define-key comint-mode-map
      (kbd "C-n") #'comint-next-input)  ; Shell.
    (define-key comint-mode-map
      (kbd "<down>") #'comint-next-input) ; Shell + RStudio.

    ;; Search backwards/forwards through input history for match for current
    ;; input.
    (define-key comint-mode-map
      (kbd "M-p") #'comint-previous-matching-input-from-input) ; Shell.
    (define-key comint-mode-map
      (kbd "<C-up>") #'comint-previous-matching-input-from-input) ; RStudio.
    (define-key comint-mode-map
      (kbd "M-n") #'comint-next-matching-input-from-input) ; Shell.
    (define-key comint-mode-map
      (kbd "<C-down>") #'comint-next-matching-input-from-input) ; RStudio.

    (with-eval-after-load "helm-autoloads"
      ;; Use Helm to search `comint' history.
      (define-key comint-mode-map
        (kbd "C-c C-l") #'helm-comint-input-ring)))
#+end_src

*** Shell History Copying

Manipulating the transcript: Viewing older commands.

- ~C-c C-p~ ::
     Move point to *previous command prompt*.

- ~C-c C-n~ ::
     Move point to *next command prompt*.

** Directory Tracking

#+begin_src emacs-lisp
;;** 38.6 Directory Tracking

  (leuven--section "38.6 Directory Tracking")
#+end_src

*************** TODO Fix case when 2 Shell buffers are run in the same dir (same name error!)
apply: Buffer name `*shell d:/Users/fni/*' is in use
*************** END

#+begin_src emacs-lisp
  (defun leuven--rename-buffer-to-curdir (&optional _string)
    "Change Shell buffer's name to current directory."
    (rename-buffer (concat "*shell " default-directory "*")))

  (add-hook 'shell-mode-hook
            #'(lambda ()
                (leuven--rename-buffer-to-curdir)
                (add-hook 'comint-output-filter-functions
                          #'leuven--rename-buffer-to-curdir nil t)))
                                        ; Local to Shell comint.
#+end_src

** Options

#+begin_src emacs-lisp
;;** 38.7 Options

  (leuven--section "38.7 Options")

  ;; Disable command echoing.
  (setq-default comint-process-echoes t) ; for Linux (not needed for Cygwin)
#+end_src

*** Paging in Shell

If you ever tried to run a program like ~git~ under ~M-x shell~, you will have come
across the warning "terminal is not fully functional" followed by unusable
behavior.  This is because ~git~ sends its output through a pager (probably ~less~),
which requires a real [[id:d12c2e1e-8147-4b39-8128-aaa70fbf4657][terminal emulator]].

Setting the ~PAGER~ environment variable to =/bin/cat= (but only inside Emacs)
solves this problem:

#+begin_src emacs-lisp
  (setenv "PAGER" "/usr/bin/cat")
#+end_src

** Term Mode
:PROPERTIES:
:ID:       d12c2e1e-8147-4b39-8128-aaa70fbf4657
:END:

To run a subshell in a text *terminal emulator*, use ~M-x term~.  This creates (or
reuses) a buffer named ~*terminal*~, and runs a subshell with input coming from
your keyboard, and output going to that buffer.

The terminal emulator uses Term mode, which has two input modes.

- In "line mode", Term basically acts like [[id:9e938c3d-3752-4c12-b3a8-cc12cdcdfd88][Shell Mode]].

- In "char mode", each character is sent directly to the subshell, as terminal
  input; the sole exception is the terminal escape character, which by default
  is ~C-c~.

#+begin_note

From my experience, none of the terminal emulators in Emacs (~term~, ~ansi-term~,
~multi-term~) is supported under Windows.  It looks like the main reason is all of
them rely on low-level support for terminals (~stty~, etc.) which is not provided
by Windows.

Though, ~term~, ~ansi-term~, and ~multi-term~ do *work in Cygwin Emacs*.
#+end_note

#+begin_src emacs-lisp
;;** 38.9 Term Mode

  (leuven--section "38.9 Term Mode")
#+end_src

Emacs *Shell mode* doesn't support (all) terminal control codes, so ~less~ doesn't
work ("page-at-a-time" feature).

Shell mode buffers do not use PTYs (pseudo-terminals), so programs running in
such a buffer (the shell, the programs run by the shell, etc.) can't perform
character-at-a-time input.  Each line is typed in full and only sent when ~RET~
is pressed.  To see proof, run the ~tty~ command in a Shell mode buffer, and its
output will be ~not a tty~.

Note that it may seem that this is not true because you can perform command-line
editing with ~C-b~, ~C-f~, etc.  But this is only because ~shell-mode~ itself
simulates the typical command-line editing features of shells like Bash, Zsh,
etc. using Emacs own internal editing capabilities.

Anyway, you can:

- use ~isearch~ to search through the command output,
- copy stuff into the kill ring or
- use the rectangle functions.

Or you might just prefer the Emacs key bindings over the ones your shell offers.

On the other hand, *Term mode* provides a proper *terminal emulator* (though not as
good as the good old ~xterm~).  You must use it for applications that are
interactive with your terminal (such as the command ~top~).

#+begin_note
In Shell mode, use ~M-x proced~ instead of ~top~.
#+end_note

#+begin_note
~MPlayer~ commands do not work in the Emacs shell.  Use ~term~ for ~/~ and ~*~ to
decrease / increase volume.
#+end_note

You can *switch to line mode* (~C-c C-j~) when you need Term to /basically/ act like
a Shell mode buffer, and move around the buffer pretty much like anywhere else
in Emacs.  Copy / kill-ring commands, ~isearch~, etc. do work.

Then, you can use ~C-c C-k~ to *switch* back *to character mode*, the default, which
is like your normal *terminal* emulator except the escape key.

It's wrong to think that ~M-x term~ captures everything it seems (which would
defeat the purpose of running it inside Emacs):

- In the default character mode, ~C-c~ is the key prefix.
- In line mode, you don't need a prefix.

Try also to use ~M-x ansi-term~ (Emacs terminal that accepts the ANSI-terminal
escape sequences) that is much better than ~term~:
- with ~M-x term~, you can run *only one shell*;
- with ~M-x ansi-term~, you can start more than one (~*ansi-term*<2>~,
  ~*ansi-term*<3>~).

Note that ~TERM~ is different in both environments:
- In ~M-x shell~, ~TERM=emacs~
- In ~M-x term~,  ~TERM=eterm-color~

MultiTerm (http://www.emacswiki.org/emacs/MultiTerm) works much better than
shell or term.

"Multi-term on POSIX hosts has let me switch from using screen, with one Emacs
screen and lots of shell screens; to just using Emacs, with lots of terminals
inside it."

#+begin_src emacs-lisp
  ;; Managing multiple terminal buffers in Emacs
  ;; (and fixing some troubles of `term-mode': key bindings, etc.).

  ;; (with-eval-after-load "multi-term-autoloads"
  ;;
  ;;   ;; (global-set-key (kbd "C-c t") #'multi-term-next)
  ;;   (global-set-key (kbd "C-c T") #'multi-term)) ; Create a new one.

  (with-eval-after-load "multi-term"

    (setq multi-term-program shell-file-name))
#+end_src

*************** TODO Try /visual/ commands (like ~top~ or ~less~) in ~multi-term~

#+begin_src emacs-lisp
  ;; ;; Run an inferior shell, with I/O through buffer `*shell*'.
  ;; (global-set-key
  ;;   (kbd "C-c !")
  ;;   (cond (leuven--win32-p 'shell)
  ;;         (t 'term)))

  ;; Toggle to and from the `*shell*' buffer.
  (global-set-key (kbd "C-!")
    #'(lambda ()
        (interactive)
        (switch-or-start 'shell "*shell*")))
#+end_src

** Remote Host

#+begin_src emacs-lisp
;;** 38.10 Remote Host Shell

  (leuven--section "38.10 Remote Host Shell")

  ;; Load ssh.el file.
  (add-to-list 'same-window-regexps "^\\*ssh-.*\\*\\(\\|<[0-9]+>\\)")
  (autoload 'ssh "ssh"
    "Open a network login connection via `ssh'." t)
    ;; This is to run ESS remotely on another computer in my own Emacs, or just
    ;; plain old reading remote files.

  ;; See http://emacs.1067599.n5.nabble.com/SSH-inside-Emacs-td225528.html
  ;; - plink (with `dumb' terminal option?) as interactive shell
  ;; - ssh -t -t user@host
  ;; - Cygwin'ized Emacs
  ;; - MSYS (MinGW)
#+end_src

** Serial Terminal

Since GNU Emacs 23, there's now support for serial port access.  The new command
~serial-term~ starts an interactive terminal on a serial port.

** Helper for GNU Emacs on w32

Let Emacs, for example, find the program =/usr/bin/gunzip=.

*But ~cygwin-mount-activate~ causes problems (Emacs crashes or unable to connect)
when reading mail with Gnus...*

Those problems disappear as soon as we do ~cygwin-mount-deactivate~...

#+begin_src emacs-lisp :tangle no
  ;; Let Windows Emacs recognize Cygwin paths (e.g. /usr/local/lib).
  (when (and leuven--win32-p
             (executable-find "mount")) ; Cygwin bin directory found.

    (with-eval-after-load "cygwin-mount-autoloads"

      (autoload 'cygwin-mount-activate "cygwin-mount"
        "Activate cygwin-mount- and cygwin-style-handling." t)

      ;; (cygwin-mount-activate)           ; This is sometimes VERY SLOW!
      ))
#+end_src

See =w32-settings.el= for more!

** Helper for Cygwin Emacs

If you want the *backslashes* in the *Windows paths* returned by Everything to be
interpreted correctly, you should use ~windows-path~.

#+begin_src emacs-lisp
  ;; Let Cygwin Emacs recognize Windows paths (e.g. C:\Program Files\).
  (when leuven--cygwin-p

    (try-require 'windows-path)         ; Require cygwin-mount!

    (with-eval-after-load "windows-path"

      ;; Activate windows-path-style-handling.
      (windows-path-activate)))
#+end_src

** Proced

#+begin_src emacs-lisp
;;* Proced

  ;; ;; Start Proced in a similar manner to Dired.
  ;; (global-set-key (kbd "C-x p") #'proced) ; Conflict with Bkmp.

  (with-eval-after-load "proced"

    ;; Current sort scheme for Proced listing.
    (setq-default proced-sort 'start)

    ;; Display of Proced buffer as process tree.
    (setq-default proced-tree-flag t))
#+end_src

#+begin_src emacs-lisp
)
#+end_src

* Using Emacs Server

#+begin_note
The Emacs version you're using and the ~emacsclient~ version you're using must be
from the *same Emacs version*...  If the latter is not the cause of a refused
connection, re-try ~M-x server-start~ in Emacs.
#+end_note

~emacsclient~ is waiting for Emacs to tell it it's done editing that file.
That's important if you use ~emacsclient~ as your ~EDITOR~.  If you want
~emacsclient~ to return immediately, use the ~-n~ option.

Do you use ~emacsclient~ in terminals?  If not, just use parameter ~-c -n~, which
creates an X Window and doesn't wait for ~(server-edit)~.

#+begin_src emacs-lisp
;;* 39 (info "(emacs)Emacs Server")

(leuven--chapter leuven-load-chapter-39-emacs-server "39 Using Emacs as a Server"

  ;; Use Emacs as a server (with the `emacsclient' program).
  (unless noninteractive
    (idle-require 'server))             ; After init.

  (with-eval-after-load "server"

    ;; Test whether server is (definitely) running, avoiding the message of
    ;; "server-start" while opening another Emacs session.
    (or (equal (server-running-p) t)

        ;; Start the Emacs server.
        (server-start))                 ; ~ 0.20 s

    ;; Save file without confirmation before returning to the client.
    (defadvice server-edit (before save-buffer-if-needed activate)
      "Save current buffer before marking it as done."
      (when server-buffer-clients (save-buffer))))

)                                       ; Chapter 39 ends here.
#+end_src

Since GNU Emacs 23, there is also a ~--daemon~ flag to start the server in a
convenient way.

*************** TODO Understand the following:

#+begin_src emacs-lisp :tangle no
        ;; (add-hook 'server-done-hook
        ;;        #'(lambda ()
        ;;          (shell-command "screen -r -X select `cat ~/tmp/emacsclient-caller`")))
#+end_src

and see
http://blog.jr0cket.co.uk/2012/10/using-emacs-24-server-on-mac-osx-for.html
for ideas about having the right ~emacsclient~ used to connect to the Emacs
server.
*************** END

#+begin_note
You can use ~emacsclient~ with a different Emacs daemon. For example, you can
start your Git checkout Emacs binary and the local installation with:

: /path/to/git/checkout/src/emacs --daemon=git
: emacs --daemon=local

and use ~emacsclient -s git~ or ~emacsclient -s local~ to connect to the daemon you
want to use.
#+end_note

* Printing Hard Copies

You can print any buffer with ~C-u M-x ps-print-buffer-with-faces RET~.  Because
of the ~C-u~, it will prompt for a file to place the PostScript into.  You can
then convert PS to PDF, if so desired.

You can print without faces (i.e. no colour) with ~ps-print-buffer~.

You may wish to set ~ps-print-landscape~ to ~t~.

See ~(info "(emacs)Windows Printing")~ for several methods of correctly setting up
printing on Windows.

#+begin_src emacs-lisp
;;* 40 (info "(emacs)Printing")

(leuven--chapter leuven-load-chapter-40-printing "40 Printing Hard Copies"

  ;; Print Emacs buffer on line printer
  ;; for {lpr,print}-{buffer,region}.
  (with-eval-after-load "lpr"

    ;; Name of program for printing a file.
    (setq lpr-command (executable-find "enscript"))
                                    ; TODO Install `enscript'.

    ;; List of strings to pass as extra options for the printer program.
    (setq lpr-switches (list "--font=Courier8"
                             "--header-font=Courier10"
                             (format "--header=%s" (buffer-name))))

    ;; Name of a printer to which data is sent for printing.
    (setq printer-name t))

  (defun leuven-ps-print-buffer-with-faces-query ()
    "Query user before printing the buffer."
    (interactive)
    (when (y-or-n-p "Are you sure you want to print this buffer? ")
      (ps-print-buffer-with-faces)))

  ;; Generate and print a PostScript image of the buffer.
  (when leuven--win32-p
    ;; Override `Print Screen' globally used as a hotkey by Windows.
    (w32-register-hot-key (kbd "<snapshot>"))
    (global-set-key
      (kbd "<snapshot>") #'leuven-ps-print-buffer-with-faces-query))

  ;; Print text from the buffer as PostScript.
  (with-eval-after-load "ps-print"

    (defvar gsprint-program
      (concat leuven--windows-program-files-dir "Ghostgum/gsview/gsprint.exe")
      "Defines the Windows path to the gsview executable.")

    (leuven--file-exists-and-executable-p gsprint-program)

    (if (and gsprint-program
             (executable-find gsprint-program))

        (progn
          ;; Name of a local printer for printing PostScript files.
          (setq ps-printer-name t)      ; Adjusted to run Ghostscript.


          ;; Name of program for printing a PostScript file.
          (setq ps-lpr-command gsprint-program)
                                        ; Tell Emacs where Ghostscript print
                                        ; utility is located.

          ;; List of extra switches to pass to `ps-lpr-command'.
          (setq ps-lpr-switches '("-query")))
                                        ; Tell Ghostscript to query which
                                        ; printer to use.
                                        ; '("-q" "-dNOPAUSE" "-dBATCH" "-sDEVICE=mswinpr2")

      (setq ps-printer-name "//PRINT-SERVER/Brother HL-4150CDN") ; XXX
      (setq ps-lpr-command "")
      (setq ps-lpr-switches '("raw")))

    ;; (setq ps-error-handler-message 'system)

    ;; Size of paper to format for.
    (setq ps-paper-type 'a4)
    (setq ps-warn-paper-type nil)

    ;; Print in portrait mode.
    (setq ps-landscape-mode nil)

    ;; (setq ps-print-control-characters nil)

    ;; Number of columns.
    (setq ps-number-of-columns 1)

    (setq ps-left-margin 40)
    (setq ps-right-margin 56)
    (setq ps-bottom-margin 22)
    (setq ps-top-margin 32)

    ;; Page layout: Header [file-name     2001-06-18 Mon]
    (setq ps-print-header-frame nil)    ; No box around the header.
    ;; See http://www.emacswiki.org/emacs/PsPrintPackage-23.
    (setq ps-header-frame-alist '((fore-color . "#CCCCCC")))
    (setq ps-header-lines 1)
    (setq ps-header-font-family 'Helvetica)
    ;; (setq ps-header-font-size 11)
    (setq ps-header-title-font-size 11)
    (defun ps-time-stamp-yyyy-mm-dd-aaa ()
      "Return date as \"yyyy-MM-dd ddd\" (ISO 8601 date + day of week)."
      (format-time-string "%Y-%m-%d %a"))
    (setq ps-right-header '(ps-time-stamp-yyyy-mm-dd-aaa))

    ;; Page layout: Footer [                         n/m]
    (setq ps-footer-offset 14)
    (setq ps-footer-line-pad .50)
    (setq ps-print-footer t)
    (setq ps-print-footer-frame nil)    ; No box around the footer.
    (setq ps-footer-frame-alist '((fore-color . "#666666")))
    (setq ps-footer-lines 1)
    (setq ps-footer-font-family 'Helvetica)
    (setq ps-footer-font-size 8)
    (setq ps-left-footer nil)
    (setq ps-right-footer (list "/pagenumberstring load")) ; Page n of m.

    (setq ps-font-family 'Courier)      ; See `ps-font-info-database'.
                                        ; Legitimate values include Courier,
                                        ; Helvetica, NewCenturySchlbk, Palatino
                                        ; and Times.

    ;; Font size, in points, for ordinary text, when generating PostScript.
    (setq ps-font-size 9.1)

    ;; Specify if face background should be used.
    (setq ps-use-face-background t)

    ;; Specify line spacing, in points, for ordinary text.
    (setq ps-line-spacing 3))

)                                       ; Chapter 40 ends here.
#+end_src

* Sorting Text

#+begin_src emacs-lisp
;;* 41 (info "(emacs)Sorting") Text

(leuven--chapter leuven-load-chapter-41-sorting "41 Sorting Text"

  ;; Key binding.
  (global-set-key (kbd "C-c ^") #'sort-lines)

)                                       ; Chapter 41 ends here.
#+end_src

To *reverse the order of* the *lines* in the region, use ~M-x reverse-region~.

* Saving Emacs Sessions

*************** TODO Check that there is no extra ~/.saves directory!

Pick up where you left off.

#+begin_src emacs-lisp
;;* 44 (info "(emacs)Saving Emacs Sessions")

(leuven--chapter leuven-load-chapter-44-saving-emacs-sessions "44 Saving Emacs Sessions"

  ;; Remember cursor position.
  (if (version< emacs-version "25.0")

      (progn
        ;; Automatically save place in each file.
        (setq-default save-place t)     ; Default value for all buffers.

        ;; Name of the file that records `save-place-alist' value.
        (setq save-place-file "~/.emacs.d/places")

        (require 'saveplace))

    (save-place-mode 1))

)                                       ; Chapter 44 ends here.
#+end_src

* Hyperlinking and Navigation Features

#+begin_src emacs-lisp
;;* 46 (info "(emacs)Hyperlinking")

(leuven--chapter leuven-load-chapter-46-hyperlinking "46 Hyperlinking and Navigation Features"
#+end_src

** Following URLs

#+begin_src emacs-lisp
  ;; Use proxy.
  (setq url-proxy-services              ;! Emacs expects just hostname and port
                                        ;! in `url-proxy-services', NOT prefixed
                                        ;! with "http://"
        `(("http"     . ,(getenv "http_proxy"))
          ("ftp"      . ,(getenv "http_proxy"))
          ("no_proxy" . "^.*example.com")))
          ;; Disable proxy for some hosts.
#+end_src

#+begin_src emacs-lisp
;;** Pass a URL to a WWW browser.

  (leuven--section "pass a URL to a WWW browser")

  ;; Default browser started when you click on some URL in the buffer.
  (setq browse-url-browser-function
        (cond ((or leuven--win32-p
                   leuven--cygwin-p)
               'browse-url-default-windows-browser)
              (leuven--mac-p
               'browse-url-default-macosx-browser)
              ((not (display-graphic-p)) ; Console.
               'eww-browse-url)
              (t                        ; Linux.
               'browse-url-generic)))

  ;; ;; TEMP For testing purpose
  ;; (setq browse-url-browser-function 'eww-browse-url)

  ;; Name of the browser program used by `browse-url-generic'.
  (setq browse-url-generic-program (executable-find "gnome-open"))
                                        ; Defer the decision to Gnome.  We could
                                        ; use "firefox" or "google-chrome" as
                                        ; well.

  ;; For WSL (Ubuntu on Windows).
  (setq browse-url-generic-program (executable-find "/mnt/c/Program Files/Internet Explorer/iexplore.exe"))
#+end_src

#+begin_src emacs-lisp :tangle no
  (setq browse-url-browser-function 'browse-url-generic)
  (setq browse-url-generic-program "cygstart")
#+end_src

** Finding Files and URLs at Point

#+begin_src emacs-lisp
  (leuven--section "FFAP")

  (unless (or (featurep 'helm-config)
              (locate-library "helm-autoloads"))

    ;; Visit a file.
    (global-set-key (kbd "<f3>") #'find-file-at-point))

  ;; Find file (or URL) at point.
  (with-eval-after-load "ffap"

    ;; Function called to fetch an URL.
    (setq ffap-url-fetcher 'browse-url)); Could be `browse-url-emacs' or
                                        ; `eww-browse-url'.
#+end_src

** Google search

*************** TODO Use engine-mode
I use Google (on C-c / g) and Github (on C-c / h), but the engine-mode readme
explains how to set it up with DuckDuckGo, stack overflow, etc.  It's
configurable, but results can be displayed in eww, Emacs' built-in text-based
web browser.
*************** END

#+begin_src emacs-lisp
;;** Web search

  (leuven--section "Web search")
#+end_src

- ~C-c g SPC~ (~google-this-region~) ::
     Search selected text.

- ~C-c g RET~ (~google-this-search~) (could be bound to ~C-S-g~?) ::
     Search user's input.

- ~C-c g n~ ::
     ~google-this-noconfirm~

- ~C-c g t~ ::
     ~google-this~

#+begin_tip
The ~M-s M-w~ key binding (new in Emacs 25) uses ~eww~ to search the web for the
text in the region.  It is super handy for quick Google and documentation
searches and this will only make it more useful.

The search engine to use for this is specified by the customizable variable
~eww-search-prefix~.
#+end_tip

~url-parse~ and ~url-cookies~ are quite heavy to load, hence:

#+begin_src emacs-lisp
  ;; A set of functions and bindings to Google under point.
  (with-eval-after-load "google-this-autoloads"

    ;; Keybinding under which `google-this-mode-submap' is assigned.
    (setq google-this-keybind (kbd "C-c g"))

    (idle-require 'google-this))

  (with-eval-after-load "google-this"

    ;; Enable Google-This mode.
    (google-this-mode 1))
#+end_src

When I want to Google most of a line, I call ~google-this-line~ and edit the
prompt. And when I to Google the entire line, hitting ~RET~ one extra time doesn't
quite bother me.

If you'd like to skip confirmation, you can define the following function and
bind it to a key:

#+begin_src emacs-lisp :tangle no
    (defun google-this-line-noconfirm (prefix)
      "Google the current line without confirmationl.
    PREFIX determines quoting."
      (interactive "P")
      (google-this-line prefix 'noconfirm))
#+end_src

#+begin_src emacs-lisp
  (defun leuven-google-search-active-region-or-word-at-point ()
    "Create a Google search URL and send it to your web browser.
  If `transient-mark-mode' is non-nil and the mark is active, it defaults to the
  current region, else to the word at or before point."
    (interactive)
    (let ((query
           (if (use-region-p)
               (buffer-substring-no-properties (region-beginning) (region-end))
             (find-tag-default))))      ; or (current-word) for word at point?
      (browse-url
       (concat
        "http://www.google.com/search?q="
        (url-hexify-string query)))))

  (defun leuven-duckduckgo-search-active-region-or-word-at-point ()
    "Create a DuckDuckGo search URL and send it to your web browser.
  If `transient-mark-mode' is non-nil and the mark is active, it defaults to the
  current region, else to the word at or before point."
    (interactive)
    (let ((query
           (if (use-region-p)
               (buffer-substring-no-properties (region-beginning) (region-end))
             (find-tag-default))))      ; or (current-word) for word at point?
      (browse-url
       (concat
        "https://duckduckgo.com/?q="
        (url-hexify-string query)))))

  (global-set-key (kbd "C-c g G") #'leuven-google-search-active-region-or-word-at-point)
  (global-set-key (kbd "C-c g D") #'leuven-duckduckgo-search-active-region-or-word-at-point)
#+end_src

** Google translate

Switch between different translation directions directly from minibuffer by
using ~C-n~ and ~C-p~ key bindings.

#+begin_src emacs-lisp
  ;; Emacs interface to Google Translate.
  (with-eval-after-load "google-translate-autoloads"

    ;; Translate a text using translation directions.
    (global-set-key (kbd "C-c t") #'google-translate-smooth-translate))

  ;; Just another UI to Google.
  (with-eval-after-load "google-translate-smooth-ui"

    ;; Translation directions.
    (setq google-translate-translation-directions-alist
          '(("fr" . "en") ("en" . "fr")
            ("fr" . "nl") ("nl" . "fr")
            ("fr" . "es") ("es" . "fr"))))

)                                       ; Chapter 46 ends here.
#+end_src

* Other Amusements

#+begin_src emacs-lisp
;;* 47 Other (info "(emacs)Amusements")

(leuven--chapter leuven-load-chapter-47-amusements "47 Other Amusements"

  ;; Define a default menu bar.
  (with-eval-after-load "menu-bar"

    ;; Get rid of the Games in the Tools menu.
    (define-key menu-bar-tools-menu [games] nil))

)                                       ; Chapter 47 ends here.
#+end_src

* Customization

Emacs 24 custom themes allow loading multiple themes simultaneously.  If you
don't want the previous theme to stay in effect, you will need to unload it
first.

Install Leuven Theme via the [[id:8c71fa50-b62e-49ae-bcbb-2ed1ee7a5d65][Emacs Lisp Packages]] (or use the one bundled in GNU
Emacs 24.4).

#+begin_src emacs-lisp
;;* 49 (info "(emacs)Customization")

(leuven--chapter leuven-load-chapter-49-customization "49 Customization"

  (ignore-errors
    ;; Load custom theme "Leuven" and enable it.
    (load-theme 'leuven t))
#+end_src

** Color

You can govern the sort order of colors now such as HSV or RGB distance from a
particular color...

#+begin_src emacs-lisp
  ;; Color sort order for `list-colors-display'.
  (setq list-colors-sort '(rgb-dist . "#FFFFFF"))
#+end_src

** Variables

#+begin_src emacs-lisp
;;** 49.3 (info "(emacs)Variables")

  (leuven--section "49.3 (emacs)Variables")

  ;; File local variables specifications are obeyed, without query --
  ;; RISKY!
  (setq enable-local-variables t)

  ;; Obey `eval' variables -- RISKY!
  (setq enable-local-eval t)

  ;; Record safe values for some local variables.
  (setq safe-local-variable-values
        '((TeX-master . t) ; Tells AUCTeX that the current file is the master document.
          (ac-sources . (ac-source-words-in-buffer ac-source-dictionary)) ; Specifies auto-complete sources.
          (flycheck-emacs-lisp-initialize-packages . t) ; Initializes packages for flycheck-mode.
          (flycheck-mode . nil) ; Disables flycheck-mode by default.
          (flyspell-mode . -1) ; Disables flyspell-mode by default.
          (flyspell-mode . 1) ; Enables flyspell-mode by default.
          (ispell-local-dictionary . "american") ; Specifies the dictionary to use for ispell.
          (ispell-local-dictionary . "francais") ; Specifies the dictionary to use for ispell.
          (org-tags-column . -80) ; Sets the column for tags in Org mode.
          (outline-minor-mode) ; Enables outline-minor-mode.
          (whitespace-style face tabs spaces trailing lines
                            space-before-tab::space newline indentation::space
                            empty space-after-tab::space space-mark tab-mark
                            newline-mark))) ; Sets whitespace style options.
#+end_src

Have a look at (info "(emacs)Directory Variables").

** Key Bindings

The keys ~C-c LETTER~ are [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Binding-Conventions.html
][reserved for user functions]].

You can get a list of all the disabled functions by typing:

#+begin_src emacs-lisp :tangle no
M-: (let (lst) (mapatoms (lambda (x) (if (get x 'disabled) (push x lst)))) lst) RET
#+end_src

#+begin_src emacs-lisp
;;** 49.4 Customizing (info "(emacs)Key Bindings")

  (leuven--section "49.4 Customizing (emacs)Key Bindings")
#+end_src

See as well Print keybindings (pkb).

#+begin_src emacs-lisp
  ;; Print the key bindings in a tabular form.
  (defun leuven-keytable (arg)
    "Print the key bindings in a tabular form."
    (interactive "sEnter a modifier string:")
    (with-output-to-temp-buffer "*Key table*"
      (let* ((i 0)
             (keys (list "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l"
                         "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x"
                         "y" "z" "<RET>" "<down>" "<up>" "<right>"
                         "<left>" "<home>" "<end>" "<f1>" "<f2>" "<f3>"
                         "<f4>" "<f5>" "<f6>" "<f7>" "<f8>" "<f9>"
                         "<f10>" "<f11>" "<f12>" "1" "2" "3" "4" "5" "6"
                         "7" "8" "9" "0" "`" "~" "!" "@" "#" "$" "%" "^"
                         "&" "*" "(" ")" "-" "_" "=" "+" "\\" "|" "{" "["
                         "]" "}" ";" "'" ":" "\"" "<" ">" "," "." "/" "?"
                         ))
             (n (length keys))
             (modifiers (list "" "S-" "C-" "M-" "M-C-"))
             (k))
        (or (string= arg "") (setq modifiers (list arg)))
        (setq k (length modifiers))
        (princ (format " %-10.10s |" "Key"))
        (let ((j 0))
          (while (< j k)
            (princ (format " %-28.28s |" (nth j modifiers)))
            (setq j (1+ j))))
        (princ "\n")
        (princ (format "_%-10.10s_|" "__________"))
        (let ((j 0))
          (while (< j k)
            (princ (format "_%-28.28s_|"
                           "_______________________________"))
            (setq j (1+ j))))
        (princ "\n")
        (while (< i n)
          (princ (format " %-10.10s |" (nth i keys)))
          (let ((j 0))
            (while (< j k)
              (let* ((binding
                      (key-binding (read-kbd-macro
                                    (concat (nth j modifiers)
                                            (nth i keys)))))
                     (binding-string "_"))
                (when binding
                  (if (eq binding 'self-insert-command)
                      (setq binding-string (concat "'" (nth i keys) "'"))
                    (setq binding-string (format "%s" binding))))
                (setq binding-string
                      (substring binding-string 0
                                 (min (length binding-string) 28)))
                (princ (format " %-28.28s |" binding-string))
                (setq j (1+ j)))))
          (princ "\n")
          (setq i (1+ i)))
        (princ (format "_%-10.10s_|" "__________"))
        (let ((j 0))
          (while (< j k)
            (princ (format "_%-28.28s_|"
                           "_______________________________"))
            (setq j (1+ j))))))
    (delete-window)
    (setq truncate-lines t))
#+end_src

#+begin_src emacs-lisp
  ;; Guide the following key bindings automatically and dynamically.
  (with-eval-after-load "which-key-autoloads"
    (idle-require 'which-key))

  (with-eval-after-load "which-key"

    (which-key-mode)

    ;; Apply suggested settings for side-window that opens on right if there is
    ;; space and the bottom otherwise.
    (which-key-setup-side-window-right-bottom)

    (setq which-key-idle-delay 0.4)

    (setq which-key-sort-order 'which-key-local-then-key-order)

    ;; Set the maximum length (in characters) for key descriptions (commands or
    ;; prefixes).
    (setq which-key-max-description-length 33))
#+end_src

** Syntax Table

The syntax table contains information that tells Emacs how to operate on text,
words, sentences etc.  It will make Emacs know enough about all the symbols in
a buffer.  Syntax table is used for example for:

- commands like ~forward-word~ (~M-f~) or ~backward-kill-word~ (~M-DEL~),
- spell-checking of words,
- expansion commands of abbrevs.

Evaluate ~current-word~ and see whether characters such as ~-~ and ~_~ are considered
part of the word (depending on the current major mode).

#+begin_src emacs-lisp
)                                       ; Chapter 49 ends here.
#+end_src

* Emacs Display

#+begin_src emacs-lisp
;;* Emacs Display

(leuven--chapter leuven-load-chapter-XX-emacs-display "XX Emacs Display"
#+end_src

** Faces

You can get text properties of any char by typing ~C-u C-x =~.

Under Windows, you can get the current *font* by typing ~(w32-select-font)~
followed by ~C-x C-e~.

You can find the current *font string* by typing
~M-x ielm RET (frame-parameters) RET~ -- see the line ~font~.

To check if some font is available in Emacs do following:

1. Switch to the ~*scratch*~ buffer.

2. Type

   ~(prin1-to-string (x-list-fonts "font-you-want-to-check or pattern"))~

3. Place the cursor after the last closing paren and hit ~C-j~.  List of the names
   of available fonts matching given pattern will appear in the current buffer
   (~*scratch*~).

4. For listing of all available fonts, use

   ~(prin1-to-string (x-list-fonts "*"))~

   or

   ~(dolist (i (x-list-fonts "*")) (princ i) (terpri))~

   for a better output.

Under Linux, use the ~xfontsel~ utility (or the command-line ~xlsfonts~) to try out
different fonts.  After choosing a font, click the select button in ~xfontsel~
window.  This will copy font name you choose to copy & paste buffer.

Now Emacs should start with that font.

#+begin_src emacs-lisp
;;** (info "(elisp)Faces")

  (leuven--section "Faces")
#+end_src

For reasons unknown to me, Emacs takes a long time to change fonts in an X
environment.

Rather than using ~(set-default-font ...)~ in =.emacs=, stick the font definition in
your =.Xresources= file (key 'Emacs*font') and then use ~xrdb -load~ to activate it.
You will find that startup time is greatly improved!

Edit your =~/.Xresources= file to have a line with "Emacs.font".  Then do a

~xrdb -merge ~/.Xresources~

or restart your X11 to validate the modification.  I let Emacs do this for me:

#+begin_src emacs-lisp
  (defun leuven--merge-x-resources ()
    (let ((file (file-name-nondirectory (buffer-file-name))))
      (when (or (string= file ".Xdefaults")
                (string= file ".Xresources"))
        (start-process "xrdb" nil "xrdb" "-merge" (buffer-file-name))
        (message (format "[Merged %s into X resource database]" file)))))

  (add-hook 'after-save-hook #'leuven--merge-x-resources)
#+end_src

#+begin_src emacs-lisp
  ;; allow any scalable font
  (setq scalable-fonts-allowed t)
#+end_src

*** UTF-8

Fonts that have a good UTF-8 coverage are:

- DejaVu Sans Mono
- FreeMono (FreeSans, FreeSerif)
- Monospace

None of them has all four variants, some have regular (medium) and bold or light
and regular, one regular and oblique.

*** Anti-aliasing

To see if anti-aliasing is active, use ~xmag~ (under Linux) or any of the other
magnifier applications.  The fonts should have gray edges.

*** Adjust the height of the default face

There are a few commands to adjust the font sizes:

- ~C-x C-+~ ::
     Increase the default face height by one step.

- ~C-x C--~ ::
     Decrease the default face height by one step.

- ~C-x C-0~ ::
     Resets to defaults.

Those bindings are global and repeatable, e.g. ~C-x C-+ C-+ C-+~.

Zoom in/out (increase/decrease the font size) with ~Ctrl~ key and scroll wheel on
the mouse:

#+begin_src emacs-lisp
  ;; (global-set-key (kbd "C-+")            #'text-scale-increase)
  ;; (global-set-key (kbd "C--")            #'text-scale-decrease)
  (global-set-key (kbd "<C-wheel-up>")   #'text-scale-increase)
  (global-set-key (kbd "<C-wheel-down>") #'text-scale-decrease)

  ;; For Linux.
  (global-set-key (kbd "<C-mouse-4>")    #'text-scale-increase)
  (global-set-key (kbd "<C-mouse-5>")    #'text-scale-decrease)
#+end_src

#+begin_src emacs-lisp
)
#+end_src

** Images
:PROPERTIES:
:ID:       9432da83-fa9d-4466-a4da-57f33d662bbd
:header-args: :tangle no
:END:

#+begin_src emacs-lisp
;;** 37.17 (info "(elisp)Images")
#+end_src

How do I get image support? See ~image-library-alist~, a list of image types vs.
external libraries needed to display them.

#+begin_src emacs-lisp
(describe-variable 'image-library-alist)
#+end_src

#+results:
#+begin_example
image-library-alist is a variable defined in `C source code'.
Its value is shown below.

  This variable is potentially risky when used as a file local variable.

Documentation:
Alist of image types vs. external libraries needed to display them.

Each element is a list (IMAGE-TYPE LIBRARY...), where the car is a symbol
representing a supported image type, and the rest are strings giving
alternate filenames for the corresponding external libraries.

Emacs tries to load the libraries in the order they appear on the
list; if none is loaded, the running session of Emacs won't
support the image type.  Types 'pbm and 'xbm don't need to be
listed; they are always supported.

Value: ((xpm "libxpm.dll" "xpm4.dll" "libXpm-nox4.dll")
 (png "libpng14-14.dll" "libpng14.dll")
 (jpeg "jpeg62.dll" "libjpeg.dll" "jpeg-62.dll" "jpeg.dll")
 (tiff "libtiff3.dll" "libtiff.dll")
 (gif "giflib4.dll" "libungif4.dll" "libungif.dll")
 (svg "librsvg-2-2.dll")
 (gdk-pixbuf "libgdk_pixbuf-2.0-0.dll")
 (glib "libglib-2.0-0.dll")
 (gobject "libgobject-2.0-0.dll"))

#+end_example

#+begin_note
You can download the corresponding dlls from ezwinports
<http://sourceforge.net/projects/ezwinports/files/> and put them into
emacs's `bin` directory.

There are some instructions in the "Image support" part on page
<https://ftp.gnu.org/gnu/emacs/windows/>.
#+end_note

If you use compiled Emacs binaries (available on the [[http://ftp.gnu.org/gnu/emacs/windows/][GNU Website]]), eventually,
copy those DLLs (=libpng16.dll=, for example) from an old Windows Emacs
installation to your Emacs =bin= directory, and restart Emacs for image support to
be enabled.

If you use Cygwin Emacs, install ~libpng~ via Cygwin as well.

You can do:

#+begin_src emacs-lisp :results silent
(image-type-available-p 'png)
#+end_src

to check if you have ~png~ image support in your Emacs.

~image-library-alist~ maps image type to a list of dlls which support it.

To check all image libraries at once:

#+begin_src emacs-lisp
(mapcar #'(lambda (elt)
            (list (car elt) (image-type-available-p (car elt))))
        dynamic-library-alist)
#+end_src

If missing image libraries bother you, read ~README.W32~ (or ~nt/INSTALL~).

For animated GIF (or multi-page TIFF):
- ~f~ steps through image frame frame, and
- ~RET~ animates.
No need for ImageMagick.

* Emacs Lisp

** Variables

*** Local Variables

#+begin_src emacs-lisp
  ;; Limit on number of Lisp variable bindings & unwind-protects.
  (setq max-specpdl-size 3000)          ; XEmacs 21.5.29
#+end_src

* Calc

~C-x *~ invokes the GNU Emacs Calculator.

** Introduction

*** Basic Commands

Start the Calc: ~C-x * c~.

*** "Quick Calculator" Mode

Run the Calculator in the minibuffer: ~M-x quick-calc~ (bound to ~C-x * q~ or
~C-x * Q~).

#+begin_note
If ~quick-calc~ is called with a prefix argument, insert the result of the
calculation into the current buffer.
#+end_note

** Embedded Mode

Try the Embedded mode of Calc: ~C-x * e~ (no need to mark the region).

Similar commands: in place of ~e~,

- ~w~ ::
     Start Embedded mode on the current "word".

- ~j~ ::
     Operate on *assignments*.

You need to type ~C-x * e~ again to exit the Embedded mode.

* IRC client for Emacs

See [[http://en.wikipedia.org/wiki/List_of_IRC_commands][List of Internet Relay Chat commands]]:
- ~/whois~
- ~/leave~

#+begin_src emacs-lisp :tangle no
;;* Emacs IRC client

;; Other IRC for Emacs: rcirc, circe, bitlbee, liece, riece, zenirc, erc
;; Circe is advised by Tassilo (contributor).

  (autoload 'circe "circe"
    "Connect to an IRC server." t)

  ;; Connect to the Freenode network
  (defun leuven-irc-connect ()
    "Connect to Freenode."
    (interactive)
    (circe "irc.freenode.net" "6667" "freenode"))

  ;; ... upon hitting `M-x leuven-start-irc'.
  (defun leuven-start-irc ()
    "Start IRC."
    (interactive)
    (switch-or-start 'leuven-irc-connect "irc.freenode.net:6667"))

  (with-eval-after-load "circe"

;;** 1 Basics

    ;; Default channels to join whenever connecting to Freenode.
    (setq circe-server-auto-join-channels
          '(("^freenode$"
             "#emacs"
             ;; "#gnus"
             ;; "#latex"
             "#org-mode"
             ;; "#stumpwm"
             ;; "#zsh"
             )))

;;** 2 Reference

;;*** 2.3 Configuration

    ;; Default nick.
    (setq circe-default-nick "johndoe")

    ;; Your "real name" on IRC.
    (setq circe-default-realname "John Doe")

    ;; Authentication info.
    (setq freenode-passwd "")
    (setq circe-nickserv-passwords
          `(("freenode" ,freenode-passwd)))

;;** 3 Fighting Information Overload

;;*** 3.1 Channels

    ;; When other people say things in buffers that are currently buried (no
    ;; window is showing them), the mode line will now show you the abbreviated
    ;; channel or nick name.  Use `C-c C-SPC' to switch to these buffers.

;;*** 3.3 Keywords

    ;; List of keywords to highlight.
    (setq lui-highlight-keywords '("org" "beamer" "ledger" "tikz"))

    ;; Add IRC color support to LUI.
    (try-require 'lui-irc-colors)
    (with-eval-after-load "lui-irc-colors"
      (add-to-list 'lui-pre-output-hook 'lui-irc-colors))

;;** 4 Hacking and Tweaking

;;*** 4.2 Using fly spell mode

    (when (leuven--executable-ispell-program-name-p)
      (setq lui-flyspell-p t)
      (setq lui-flyspell-alist '(("." "american"))))

;;** Others

    (setq circe-highlight-nick-type 'occurrence)

    (try-require 'circe-highlight-all-nicks)
    (with-eval-after-load "circe-highlight-all-nicks"
      (enable-circe-highlight-all-nicks))

    ;; Format for messages to queries or channels.
    (setq circe-format-self-say "<{nick}> {body}")

    ;; Truncate the buffer (at the top) if it grows too much.
    (setq lui-max-buffer-size 30000)

    ;; Column at which Lui should break output.
    (setq lui-fill-column fill-column)

    )                                   ; with-eval-after-load "circe" ends here.
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package erc
  :commands (erc erc-tls)
  :bind (:map erc-mode-map
              ("C-c r" . reset-erc-track-mode))
  :preface
  (defun irc (&optional arg)
    (interactive "P")
    (if arg
        (pcase-dolist (`(,server . ,nick)
                       '(("irc.freenode.net"     . "johnw")
                         ("irc.gitter.im"        . "jwiegley")
                         ;; ("irc.oftc.net"         . "johnw")
                         ))
          (erc-tls :server server :port 6697 :nick (concat nick "_")
                   :password (lookup-password server nick 6697)))
      (let ((pass (lookup-password "irc.freenode.net" "johnw" 6697)))
        (when (> (length pass) 32)
          (error "Failed to read ZNC password"))
        (erc :server "127.0.0.1" :port 6697 :nick "johnw"
             :password (concat "johnw/gitter:" pass))
        (sleep-for 5)
        (erc :server "127.0.0.1" :port 6697 :nick "johnw"
             :password (concat "johnw/freenode:" pass)))))

  (defun reset-erc-track-mode ()
    (interactive)
    (setq erc-modified-channels-alist nil)
    (erc-modified-channels-update)
    (erc-modified-channels-display)
    (force-mode-line-update))

  (defun setup-irc-environment ()
    (set (make-local-variable 'scroll-conservatively) 100)
    (setq erc-timestamp-only-if-changed-flag nil
          erc-timestamp-format "%H:%M "
          erc-fill-prefix "          "
          erc-fill-column 78
          erc-insert-timestamp-function 'erc-insert-timestamp-left
          ivy-use-virtual-buffers nil))

  (defcustom erc-foolish-content '()
    "Regular expressions to identify foolish content.
    Usually what happens is that you add the bots to
    `erc-ignore-list' and the bot commands to this list."
    :group 'erc
    :type '(repeat regexp))

  (defun erc-foolish-content (msg)
    "Check whether MSG is foolish."
    (erc-list-match erc-foolish-content msg))

  :init
  (add-hook 'erc-mode-hook #'setup-irc-environment)
  (when alternate-emacs
    (add-hook 'emacs-startup-hook 'irc))

  (eval-after-load 'erc-identd
    '(defun erc-identd-start (&optional port)
       "Start an identd server listening to port 8113.
  Port 113 (auth) will need to be redirected to port 8113 on your
  machine -- using iptables, or a program like redir which can be
  run from inetd. The idea is to provide a simple identd server
  when you need one, without having to install one globally on
  your system."
       (interactive (list (read-string "Serve identd requests on port: " "8113")))
       (unless port (setq port erc-identd-port))
       (when (stringp port)
         (setq port (string-to-number port)))
       (when erc-identd-process
         (delete-process erc-identd-process))
       (setq erc-identd-process
             (make-network-process :name "identd"
                                   :buffer nil
                                   :host 'local :service port
                                   :server t :noquery t
                                   :filter 'erc-identd-filter))
       (set-process-query-on-exit-flag erc-identd-process nil)))

  :config
  (erc-track-minor-mode 1)
  (erc-track-mode 1)

  (add-hook 'erc-insert-pre-hook
            #'(lambda (s)
                (when (erc-foolish-content s)
                  (setq erc-insert-this nil)))))

(use-package erc-alert
  :disabled t
  :after erc)

(use-package erc-highlight-nicknames
  :after erc)

(use-package erc-macros
  :after erc)

(use-package erc-patch
  :disabled t
  :after erc)

(use-package erc-question
  :disabled t
  :after erc)

(use-package erc-yank
  :load-path "lisp/erc-yank"
  :after erc
  :bind (:map erc-mode-map
              ("C-y" . erc-yank )))
#+end_src

* Emacs and Microsoft Windows/MS-DOS

Eventually have a look as well at ~input-decode-map~.

#+begin_src emacs-lisp
;;* App G Emacs and (info "(emacs)Microsoft Windows/MS-DOS")

(leuven--chapter leuven-load-chapter-AppG-ms-dos "Appendix G Emacs and MS-DOS"

  ;; Divide key (needed in GNU Emacs for Windows).
  (global-set-key (kbd "<kp-divide>") (kbd "/"))

)                                       ; Chapter G ends here.
#+end_src

* Profiler

#+begin_src emacs-lisp
;;* Profiler

  (with-eval-after-load "profiler"

    (setq profiler-report-cpu-line-format
      '((100 left)                      ; The 100 above is increased from the
                                        ; default of 50 to allow the deeply
                                        ; nested call tree to be seen.
        (24 right ((19 right)
                   (5 right))))))
#+end_src

* Reporting Bugs

To get a backtrace when a specific regexp is displayed in the echo area (through
calls to message), set the variable ~debug-on-message~.

#+begin_src emacs-lisp
;; Recovery from Problems

;;* Reporting Bugs

(leuven--chapter leuven-load-chapter-99-debugging "99 Debugging"

  ;; Get the backtrace when uncaught errors occur.
  (setq debug-on-error nil)             ; Was set to `t' at beginning of file.

  ;; Hit `C-g' while it's frozen to get an Emacs Lisp backtrace.
  (setq debug-on-quit nil)              ; Was set to `t' at beginning of file.

  (setq debug-on-entry 'user-error))

;; (use-package ert
;;   :bind ("C-c e t" . ert-run-tests-interactively))
#+end_src

#+begin_src emacs-lisp
(when (and (string-match "GNU Emacs" (version))
           leuven-verbose-loading)
  (ad-disable-advice 'message 'before 'leuven-when-was-that)
  (ad-update 'message))
#+end_src

#+begin_src emacs-lisp
(when leuven-verbose-loading
  (message "| Chapter | Time |")
  (message "|---------+------|")
  (mapcar #'(lambda (el)                  ; FIXME Use `mapc' or `dolist'.
              (message el))
          (nreverse leuven--load-times-list))
  (message "|---------+------|")
  (message "|         | =vsum(@-I..@-II) |"))
#+end_src

* Post Init

#+begin_src emacs-lisp
(let ((elapsed (float-time (time-subtract (current-time)
                                          leuven--start-time))))
  (message "[Loaded %s in %.2f s]" load-file-name elapsed))
(sit-for 0.3)

#+end_src

See https://github.com/emacs-dashboard/emacs-dashboard/issues/57 (very nice
dashboard):

#+begin_src emacs-lisp
;; ;; (use-package dashboard
;; ;;   :if (< (length command-line-args) 2)
;; ;;   :preface
;;   (defun my/dashboard-banner ()
;;     "Sets a dashboard banner including information on package initialization
;;      time and garbage collections."
;;     (setq dashboard-banner-logo-title
;;           (format "Emacs ready in %.2f seconds with %d garbage collections."
;;                   (float-time
;;                    (time-subtract after-init-time before-init-time)) gcs-done)))
;;   ;; :init
;;   (add-hook 'after-init-hook 'dashboard-refresh-buffer)
;;   (add-hook 'dashboard-mode-hook 'my/dashboard-banner)
;;   ;; :custom
;;   ;; (dashboard-startup-banner 'logo)
;;   ;; :config
;;   (dashboard-setup-startup-hook)
;; ;; )
#+end_src

#+begin_src emacs-lisp
(add-hook 'after-init-hook
          #'(lambda ()
              (message "[Emacs startup time: %.2f s; GC done: %S]"
                       (string-to-number (emacs-init-time)) gcs-done)
              (sit-for 0.3))
  t)
#+end_src

* Leuven

If you are like me, you want to know if there are:

- changes to existing files
- newly added files
- deleted files

and specifically do not want to know about *untracked files*.

This should do it:

#+begin_src shell :tangle no
git status --untracked-files=no --porcelain
#+end_src

See https://github.com/mordocai/.emacs.d/blob/master/init.el for many Git
functions implemented in Emacs Lisp.

"Package can be upgraded"

#+begin_src emacs-lisp
  (defun leuven-update ()
    "Update Emacs-Leuven to its latest version."
    (interactive)
    (leuven-emacs-version)
    (message "[Updating Leuven...]")
    (cd leuven--directory)
    (let ((ret (shell-command-to-string "LC_ALL=C git pull --rebase")))
      (if (string-match "\\(up to date\\|up-to-date\\)" ret)
          (message "[Configuration already up-to-date]")
        (princ ret)
        (sit-for 3)
        (message "[Configuration updated. Restart Emacs to complete the process]"))))

  (defun leuven-show-latest-commits ()
    "List latest changes in Emacs-Leuven."
    (interactive)
    (leuven-emacs-version)
    (message "[Fetching last changes in Leuven...]")
    (cd leuven--directory)
    (let ((ret (shell-command-to-string "LC_ALL=C git fetch --verbose"))
          (bufname "*Leuven latest commits*"))
      (if (string-match "\\(up to date\\|up-to-date\\)" ret)
          (message "[Configuration already up-to-date]")
       (with-output-to-temp-buffer bufname
         (shell-command
          "LC_ALL=C git log --pretty=format:'%h %ad %s' --date=short HEAD..origin"
          bufname)
         (pop-to-buffer bufname)))))

  (defun leuven-emacs-version ()
    (interactive)
    (message "[Emacs-Leuven version %s]" leuven--emacs-version))
#+end_src

# See spacemacs/check-for-new-version.

Please address particular issues or suggestions *specifically*, using ~M-x
leuven-send-bug-report~.

#+begin_src emacs-lisp
(message "* --[ Loaded Emacs-Leuven %s]--" leuven--emacs-version)
#+end_src

** Feature

#+begin_src emacs-lisp
(provide 'emacs-leuven)
#+end_src

** File Local Variables

#+begin_src emacs-lisp
;; This is for the sake of Emacs.
;; Local Variables:
;; coding: utf-8-unix
;; eval: (when (require 'rainbow-mode nil t) (rainbow-mode))
;; flycheck-emacs-lisp-initialize-packages: t
;; flycheck-mode: nil
;; ispell-local-dictionary: "american"
;; End:

;;; emacs-leuven.el ends here
#+end_src

# emacs-leuven.txt ends here
