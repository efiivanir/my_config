* Searching and Replacement

#+begin_src emacs-lisp
;;* 15 (info "(emacs)Search")ing and Replacement

(leuven--chapter leuven-load-chapter-15-search "15 Searching and Replacement"
#+end_src

** Incremental Search (aka "Live Search")

Have a look at the "Standard Isearch Keys" on
http://www.emacswiki.org/emacs/IncrementalSearch

Isearch has a binding which deletes all the non-matching characters from the
search string: ~C-g~ (not a very intuitive binding, because it's usually
associated with aborting operations, not with correcting things).

If you hit ~M-e~ (to edit the search string), the cursor is moved to the mismatch
position.

Since Emacs 24.3:
- ~M-s _~ starts a symbol (identifier) incremental search.
- ~M-s _~ in Isearch toggles symbol search mode.
- ~M-s c~ in Isearch toggles search case-sensitivity.

Since Emacs 27.1, to *go to the first/last occurrence of the current search
string* is possible with new commands ~isearch-beginning-of-buffer~ and
~isearch-end-of-buffer~ bound to ~M-s M-<~ and ~M-s M->~ in Isearch.

#+begin_src emacs-lisp
;;** 15.1 (info "(emacs)Incremental Search")

  (leuven--section "15.1 (emacs)Incremental Search")

  ;; FIXME Error when selecting search string from kill ring (`M-p')
  ;; ;; Always exit searches at the beginning of the expression found.
  ;; (add-hook 'isearch-mode-end-hook #'isearch-goto-match-beginning)
  ;;
  ;; (defun isearch-goto-match-beginning ()
  ;;   "Use with isearch hook to end search at first char of match."
  ;;   (when isearch-forward (goto-char isearch-other-end)))

  ;; ;; Incremental search/query-replace will open the contents.
  ;; (setq search-invisible 'open)         ; XXX

  ;; Don't re-hide an invisible match right away.
  (setq isearch-hide-immediately nil)   ; XXX

  ;; Scrolling commands are allowed during incremental search (without canceling
  ;; Isearch mode).
  (setq isearch-allow-scroll t)
#+end_src

Search for string ignoring new lines: incremental search will see any number of
white spaces, tab spaces, and line breaks as a simple white space.

#+begin_src emacs-lisp
(setq isearch-regexp-lax-whitespace t)
(setq search-whitespace-regexp "[ \t\r\n]+")
#+end_src

#+begin_note
When ~search-invisible~ is ~t~, ~perform-replace~ can replace matches in any invisible
text, but does not display it when prompting the user for confirmation.

When ~search-invisible~ is ~'open~, ~perform-replace~ can replace matches only in
hidden text (invisible through an overlay), and displays it when prompting the
user.

We lack a way to reveal truly invisible text when performing a search and
replace.  The URL of a bracket link in Org is an example of such truly invisible
text.

Juri's solution to add ~'open-all~ could also be used in ~perform-replace~ to let
the user see truly invisible matches before replacing them.
#+end_note

#+begin_src emacs-lisp
	;; Fuzzy matching utilities (a must-have).
	(use-package fuzzy
	  :config
	  (autoload 'turn-on-fuzzy-isearch "fuzzy" nil t)
										  ; This autoload isn't defined in
										  ; `fuzzy-autoloads'!

	  (add-hook 'isearch-mode-hook #'turn-on-fuzzy-isearch)
	  )
#+end_src

#+begin_src emacs-lisp
  ;; Show number of matches in mode-line while searching.
  (use-package anzu
	:config
	;; Lighter of anzu-mode.
	(setq anzu-mode-lighter "")
	;; Deactive region if you use anzu a replace command with region.
	(setq anzu-deactivate-region t)
	;; Separator of `to' string.
	(setq anzu-replace-to-string-separator " => ")
	;; Function which returns mode-line string.
	(defun leuven--anzu-update-mode-line (here total)
	  (when anzu--state
		(let ((status (cl-case anzu--state
						(search (format (if (> total 1)
											" %s of %d%s matches "
										  " %s of %d%s match ")
										(anzu--format-here-position here total)
										total (if anzu--overflow-p "+" "")))
						(replace-query (format " %d replace " total))
						(replace (format (if (> total 1)
											 " %d of %d matches "
										   " %d of %d match ")
										 here total))))
			  (face (if (and (zerop total) (not (string= isearch-string "")))
						'anzu-mode-line-no-match
					  'anzu-mode-line)))
		  (propertize status 'face face))))
	(setq anzu-mode-line-update-function #'leuven--anzu-update-mode-line)

	;; Enable Global-Anzu mode.
	(global-anzu-mode 1)

	;; Override binding for `query-replace'.
	(global-set-key (kbd "M-%")   #'anzu-query-replace)
	(global-set-key (kbd "C-M-%") #'anzu-query-replace-regexp)

	;; (define-key isearch-mode-map (kbd "M-%") #'anzu-query-replace)
	)
#+end_src

** Symbol Search

- ~M-s .~ (~isearch-forward-symbol-at-point~) ::
     Start a symbol (identifier) incremental search forward with the symbol
     found near point added to the search string initially.

** Regexp Search

Emacs uses basic regular expressions, which means that the extended regexp
operators have to be escaped.  This means you have to use ~\(~, ~\|~, and ~\)~
instead of ~(~, ~|~, and ~)~.

You can build regexps with visual feedback by using:
- ~M-x re-builder~ or
- ~M-x regex-tool~ (by John Wiegley)

Optimize regexps with =regexp-opt.el=.

#+begin_src emacs-lisp
;;** 15.5 (info "(emacs)Regexp Search")

  (leuven--section "15.5 (emacs)Regexp Search")
#+end_src

#+begin_src emacs-lisp :tangle no
  ;; Use regexps by default (allows searching across line breaks).
  (global-set-key (kbd "C-s") #'isearch-forward-regexp)
  (global-set-key (kbd "C-r") #'isearch-backward-regexp)

  ;; Shift the meaning of `C-M-s/r' with `C-s/r'.
  (global-set-key (kbd "C-M-s") #'isearch-forward)
  (global-set-key (kbd "C-M-r") #'isearch-backward)
#+end_src

** Search Case

#+begin_src emacs-lisp
;;** 15.9 (info "(emacs)Search Case")

  (leuven--section "15.9 (emacs)Search Case")
#+end_src

*Case folding* folds together "a" and "A".

#+begin_src emacs-lisp
  ;; Searches should ignore case by default (in all buffers that do not
  ;; override this).
  (setq-default case-fold-search t)
#+end_src

*Char folding* allows simple ASCII characters to match their complex Unicode
counterparts.  For instance, if you search for "a", you will also match "á" and
"ã"; that is, char folding folds together "a", "á" and "ã".

#+begin_src emacs-lisp :tangle no
  (setq search-default-mode 'char-fold-to-regexp)
#+end_src

You can also *toggle character folding* in the middle of a search by typing ~M-s '~.

** Replacement Commands

Pass the string or the regexp directly to ~query-replace~, so you can't mangle it
on the way, by pressing ~M-%~ while at the ~I-search:~ prompt.

~query-replace~ honors *character folding* if the new variable ~replace-char-fold~ is
customized to a non-nil value.

** Other Search-and-Loop Commands

~M-x flush-lines~ (or ~delete-matching-lines~) deletes each line that contains
a match for REGEXP.

There is also the opposite command, ~M-x keep-lines~, which deletes all lines
except those containing matches for REGEXP.

#+begin_src emacs-lisp
;;** 15.11 (info "(emacs)Other Repeating Search") Commands

  (leuven--section "15.11 (emacs)Other Repeating Search Commands")

  (global-unset-key (kbd "M-o")) ; XXX???

  ;; "Multi-occur" easily inside Isearch.
  (define-key isearch-mode-map (kbd "M-o") #'helm-multi-swoop-all)

  ;; Grep all same extension files from inside Isearch.
  (defun leuven-isearch-grep ()
    "Start grep using current isearch string."
    (interactive)
    (let* ((search-str (if isearch-regexp isearch-string (regexp-quote isearch-string)))
           (file-pattern (if (buffer-file-name)
                             (format "*.%s" (file-name-extension (buffer-file-name)))
                           "*"))
           (default-dir default-directory))
      (grep-compute-defaults)
      (lgrep search-str file-pattern default-dir)
      (isearch-abort)))

  (define-key isearch-mode-map (kbd "C-M-o") #'leuven-isearch-grep)
#+end_src

#+begin_src emacs-lisp
)                                       ; Chapter 15 ends here.
#+end_src

